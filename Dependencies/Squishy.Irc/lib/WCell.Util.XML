<?xml version="1.0"?>
<doc>
    <assembly>
        <name>WCell.Util</name>
    </assembly>
    <members>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskSchedulerExtensions.ToSynchronizationContext(System.Threading.Tasks.TaskScheduler)">
            <summary>Gets a SynchronizationContext that targets this TaskScheduler.</summary>
            <param name="scheduler">The target scheduler.</param>
            <returns>A SynchronizationContext that targets this scheduler.</returns>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.TaskSchedulerExtensions.TaskSchedulerSynchronizationContext">
            <summary>Provides a SynchronizationContext wrapper for a TaskScheduler.</summary>
        </member>
        <member name="F:WCell.Util.Threading.TaskParallel.TaskSchedulerExtensions.TaskSchedulerSynchronizationContext._scheduler">
            <summary>The scheduler.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskSchedulerExtensions.TaskSchedulerSynchronizationContext.#ctor(System.Threading.Tasks.TaskScheduler)">
            <summary>Initializes the context with the specified scheduler.</summary>
            <param name="scheduler">The scheduler to target.</param>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskSchedulerExtensions.TaskSchedulerSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <summary>Dispatches an asynchronous message to the synchronization context.</summary>
            <param name="d">The System.Threading.SendOrPostCallback delegate to call.</param>
            <param name="state">The object passed to the delegate.</param>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskSchedulerExtensions.TaskSchedulerSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <summary>Dispatches a synchronous message to the synchronization context.</summary>
            <param name="d">The System.Threading.SendOrPostCallback delegate to call.</param>
            <param name="state">The object passed to the delegate.</param>
        </member>
        <member name="T:WCell.Util.Commands.CmdTrigger`1">
            <summary>
            CmdTriggers trigger Commands. There are different kinds of triggers which are handled differently, 
            according to where they came from.
            
            </summary>
            TODO: Have a reply-stream.
        </member>
        <member name="F:WCell.Util.Commands.CmdTrigger`1.Alias">
            <summary>
            The alias that has been used to trigger this command.
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.CmdTrigger`1.Reply(System.String)">
            <summary>
            Replies accordingly with the given text.
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.CmdTrigger`1.ReplyFormat(System.String)">
            <summary>
            Replies accordingly with the given formatted text.
            </summary>
        </member>
        <member name="P:WCell.Util.Commands.CmdTrigger`1.Command">
            <summary>
            That command that has been triggered or null if the command for this <code>Alias</code> could
            not be found.
            </summary>
        </member>
        <member name="P:WCell.Util.Commands.CmdTrigger`1.SelectedCommand">
            <summary>
            That command that was selected when triggering this Trigger.
            </summary>
        </member>
        <member name="P:WCell.Util.Commands.CmdTrigger`1.Text">
            <summary>
            A <code>StringStream</code> which contains the supplied arguments.
            </summary>
        </member>
        <member name="T:WCell.Util.Collections.ImmutableDictionary`2">
            <summary>
            Represents a per-thread immutable collection of keys and values.
            </summary>
            <remarks>
            This class is immutable in the sense of a string; you never change the
            collection itself, but rather you create a copy of it, and modify the copy,
            which then replaces the old dictionary.  All updates are atomic with the use 
            of the <see cref="T:System.Threading.Interlocked"/> class.
            </remarks>
            <typeparam name="TKey">the type of the keys in the dictionary</typeparam>
            <typeparam name="TValue">the type of the values in the dictionary</typeparam>
        </member>
        <member name="M:WCell.Util.Collections.ImmutableDictionary`2.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:WCell.Util.Collections.ImmutableDictionary`2.#ctor(System.Int32)">
            <summary>
            Creates a dictionary with the specified initial capacity.
            </summary>
            <param name="capacity">the starting capacity of the dictionary</param>
        </member>
        <member name="M:WCell.Util.Collections.ImmutableDictionary`2.Add(`0,`1)">
            <summary>
            Adds the specified key and value to the dictionary.
            </summary>
            <param name="key">the key of the element to add</param>
            <param name="value">the value of the element to add</param>
        </member>
        <member name="M:WCell.Util.Collections.ImmutableDictionary`2.Remove(`0)">
            <summary>
            Removes the value with the specified key from the dictionary.
            </summary>
            <param name="key">the key of the element to remove</param>
            <returns>true if the element is found and removed; false if the key does not exist</returns>
        </member>
        <member name="M:WCell.Util.Collections.ImmutableDictionary`2.Clear">
            <summary>
            Removes all keys and values from the dictionary.
            </summary>
        </member>
        <member name="M:WCell.Util.Collections.ImmutableDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether or not the key is contained in the dictionary.
            </summary>
            <param name="key">the key to locate in the dictionary</param>
            <returns>true if the dictionary contains an element with the specified key; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.Collections.ImmutableDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the dictionary
            </summary>
            <returns>an enumerator structure for the list</returns>
        </member>
        <member name="M:WCell.Util.Collections.ImmutableDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">the key of the value to get</param>
            <param name="value">
            when the method returns, contains the value associated with the key, 
            if the key is found; otherwise it is the default value for the type 
            of the value parameter
            </param>
            <returns>true if the dictionary contains an element with the specified key; false otherwise</returns>
        </member>
        <member name="P:WCell.Util.Collections.ImmutableDictionary`2.Count">
            <summary>
            The number of key/value pairs in the dictionary.
            </summary>
        </member>
        <member name="P:WCell.Util.Collections.ImmutableDictionary`2.IsReadOnly">
            <summary>
            Whether or not this dictionary is read-only.
            </summary>
        </member>
        <member name="P:WCell.Util.Collections.ImmutableDictionary`2.Keys">
            <summary>
            Gets a collection containing all the keys in the dictionary.
            </summary>
        </member>
        <member name="P:WCell.Util.Collections.ImmutableDictionary`2.Values">
            <summary>
            Gets a collection containing all the values in the dictionary.
            </summary>
        </member>
        <member name="P:WCell.Util.Collections.ImmutableDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">the key of the value to get or set</param>
            <returns>
            the value associated with the specified key; if the key does not exist, 
            a get operation will throw a KeyNotFoundException, and a set operation 
            creates a new element with the key
            </returns>
        </member>
        <member name="F:WCell.Util.XmlFileBase.m_filename">
            <summary>
            The file name of the configuration file.
            </summary>
        </member>
        <member name="M:WCell.Util.XmlFile`1.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="fileName">The name of the configuration file.</param>
        </member>
        <member name="M:WCell.Util.XmlFile`1.FileExists(System.String)">
            <summary>
            Returns whether or not the file exists
            </summary>
        </member>
        <member name="M:WCell.Util.XmlFile`1.Save">
            <summary>
            Writes the configuration file to disk.
            </summary>
        </member>
        <member name="M:WCell.Util.XmlFile`1.SaveAs(System.String)">
            <summary>
            Writes the configuration file to disk with the specified name.
            </summary>
            <param name="fileName">The name of the file on disk to write to.</param>
        </member>
        <member name="M:WCell.Util.XmlFile`1.SaveAs(System.String,System.String)">
            <summary>
            Writes the configuration file to disk with the specified name.
            </summary>
            <param name="fileName">The name of the file on disk to write to.</param>
            <param name="location">The directory to write the file to.</param>
        </member>
        <member name="M:WCell.Util.XmlFile`1.ToString">
            <summary>
            Returns the serialized XML of this XmlConfig for further processing, etc.
            </summary>
        </member>
        <member name="T:WCell.Util.Commands.BaseCommand`1">
            <summary>
            An abstract base class, for Command and SubCommand. 
            Can hold SubCommands which again can hold further SubCommands.
            </summary>
        </member>
        <member name="F:WCell.Util.Commands.BaseCommand`1.Aliases">
            <summary>
            All Aliases which can trigger the Process method of this Command.
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.BaseCommand`1.CreateUsage">
            <summary>
            Returns a simple usage string
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.BaseCommand`1.Process(WCell.Util.Commands.CmdTrigger{`0})">
            <summary>
            Is called when the command is triggered (case-insensitive).
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.BaseCommand`1.Eval(WCell.Util.Commands.CmdTrigger{`0})">
            <summary>
            Processes a command that yields an object to return
            </summary>
            <param name="trigger"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Commands.BaseCommand`1.CreateGroupUsageString">
            <summary>
            Creates a default string of all aliases and all subcommands
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.BaseCommand`1.SelectSubCommand(System.String)">
            <summary>
            Returns the direct SubCommand with the given alias.
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Commands.BaseCommand`1.SelectSubCommand(WCell.Util.Strings.StringStream)">
            <summary>
            Returns the SubCommand, following the given set of aliases through the SubCommand structure.
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.BaseCommand`1.GetSubCommands(WCell.Util.Strings.StringStream,System.Collections.Generic.List{WCell.Util.Commands.BaseCommand{`0}})">
            <summary>
            Returns the SubCommand, following the given set of aliases through the SubCommand structure.
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.BaseCommand`1.OnFail(WCell.Util.Commands.CmdTrigger{`0},System.Exception)">
            <summary>
            Is triggered when the processing throws an Exception.
            </summary>
        </member>
        <member name="P:WCell.Util.Commands.BaseCommand`1.RootCmd">
            <summary>
            The actual Command itself to which this SubCommand (and maybe its ancestors) belongs
            </summary>
        </member>
        <member name="P:WCell.Util.Commands.BaseCommand`1.ParentCmd">
            <summary>
            The parent of this SubCommand (can be a further SubCommand or a Command)
            </summary>
        </member>
        <member name="P:WCell.Util.Commands.BaseCommand`1.Enabled">
            <summary>
            Indicates whether or not this command is enabled.
            If false, Commands.ReactTo will not trigger this Command'str Process method.
            Alternatively you can Add/Remove this Command to/from Commands.CommandsByAlias to control whether or not
            certain Commands should or should not be used.
            </summary>
        </member>
        <member name="P:WCell.Util.Commands.BaseCommand`1.EnglishParamInfo">
            <summary>
            A human-readable list of expected parameters
            </summary>
        </member>
        <member name="P:WCell.Util.Commands.BaseCommand`1.EnglishDescription">
            <summary>
            Describes the command itself.
            </summary>
        </member>
        <member name="T:WCell.Util.Collections.SynchronizedList`1">
            <summary>
            Not actually synchronized.
            It's especially missing a synchronized enumerator.
            </summary>
        </member>
        <member name="T:WCell.Util.Collections.LockFreeStack`1">
            <summary>
            Represents a lock-free, thread-safe, last-in, first-out collection of objects.
            </summary>
            <typeparam name="T">specifies the type of the elements in the stack</typeparam>
        </member>
        <member name="M:WCell.Util.Collections.LockFreeStack`1.#ctor">
            <summary>
            Default constructors.
            </summary>
        </member>
        <member name="M:WCell.Util.Collections.LockFreeStack`1.Push(`0)">
            <summary>
            Inserts an object at the top of the stack.
            </summary>
            <param name="item">the object to push onto the stack</param>
        </member>
        <member name="M:WCell.Util.Collections.LockFreeStack`1.Pop(`0@)">
            <summary>
            Removes and returns the object at the top of the stack.
            </summary>
            <param name="item">
            when the method returns, contains the object removed from the top of the stack, 
            if the queue is not empty; otherwise it is the default value for the element type
            </param>
            <returns>
            true if an object from removed from the top of the stack 
            false if the stack is empty
            </returns>
        </member>
        <member name="M:WCell.Util.Collections.LockFreeStack`1.Pop">
            <summary>
            Removes and returns the object at the top of the stack.
            </summary>
            <returns>the object that is removed from the top of the stack</returns>
        </member>
        <member name="M:WCell.Util.Graphics.RectInt32.Contains(System.Int32,System.Int32)">
            <summary>
            Whether the rectangle contains the given Point(x, y). 
            Points laying on the rectangles border are considered to be contained.
            </summary>
        </member>
        <member name="M:WCell.Util.Variables.VariableDefinition.Eval(System.Type)">
            <summary>
            Copies the actual Value 
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.ParallelLinqExtensions">
            <summary>Extension methods for Parallel LINQ.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.ParallelLinqExtensions.TakeTop``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Int32)">
            <summary>Takes the top elements as if they were sorted.</summary>
            <typeparam name="TSource">Specifies the type of the elements.</typeparam>
            <typeparam name="TKey">Specifies the type of the keys used to compare elements.</typeparam>
            <param name="source">The source elements.</param>
            <param name="keySelector">A function used to extract a key from each element.</param>
            <param name="count">The number of elements to take.</param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.ParallelLinqExtensions.MapReduce``4(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``1,``2},System.Func{System.Linq.IGrouping{``2,``1},``3})">
            <summary>Implements a map-reduce operation.</summary>
            <typeparam name="TSource">Specifies the type of the source elements.</typeparam>
            <typeparam name="TMapped">Specifies the type of the mapped elements.</typeparam>
            <typeparam name="TKey">Specifies the type of the element keys.</typeparam>
            <typeparam name="TResult">Specifies the type of the results.</typeparam>
            <param name="source">The source elements.</param>
            <param name="map">A function used to get the target data from a source element.</param>
            <param name="keySelector">A function used to get a key from the target data.</param>
            <param name="reduce">A function used to reduce a group of elements.</param>
            <returns>The result elements of the reductions.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.ParallelLinqExtensions.MapReduce``4(System.Linq.ParallelQuery{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``1,``2},System.Func{System.Linq.IGrouping{``2,``1},System.Collections.Generic.IEnumerable{``3}})">
            <summary>Implements a map-reduce operation.</summary>
            <typeparam name="TSource">Specifies the type of the source elements.</typeparam>
            <typeparam name="TMapped">Specifies the type of the mapped elements.</typeparam>
            <typeparam name="TKey">Specifies the type of the element keys.</typeparam>
            <typeparam name="TResult">Specifies the type of the results.</typeparam>
            <param name="source">The source elements.</param>
            <param name="map">A function used to get an enumerable of target data from a source element.</param>
            <param name="keySelector">A function used to get a key from target data.</param>
            <param name="reduce">A function used to reduce a group of elements to an enumerable of results.</param>
            <returns>The result elements of the reductions.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.ParallelLinqExtensions.OutputToProducerConsumerCollection``1(System.Linq.ParallelQuery{``0},System.Collections.Concurrent.IProducerConsumerCollection{``0})">
            <summary>Runs the query and outputs its results into the target collection.</summary>
            <typeparam name="TSource">Specifies the type of elements output from the query.</typeparam>
            <param name="source">The source query.</param>
            <param name="target">The target collection.</param>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.ParallelLinqExtensions.AsParallel``1(System.Collections.Generic.IEnumerable{``0},WCell.Util.Threading.TaskParallel.ParallelLinqOptions)">
            <summary>This is the method to opt into Parallel LINQ.</summary>
            <typeparam name="TSource">Specifies the type of elements provided to the query.</typeparam>
            <param name="source">The source query.</param>
            <param name="parallelOptions">The options to use for query processing.</param>
            <returns>The source as a ParallelQuery to bind to ParallelEnumerable extension methods.</returns>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.ParallelLinqExtensions.DescendingDefaultComparer`1">
            <summary>A comparer that comparers using the inverse of the default comparer.</summary>
            <typeparam name="T">Specifies the type being compared.</typeparam>
        </member>
        <member name="T:WCell.Util.Graphics.BoundingSphere">
            <summary>
            Defines a sphere.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.BoundingSphere.Center">
            <summary>
            The center point of the sphere.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.BoundingSphere.Radius">
            <summary>
            The radius of the sphere.
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingSphere.#ctor(WCell.Util.Graphics.Vector3,System.Single)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.BoundingSphere"/> with the given center point and radius.
            </summary>
            <param name="point">the center point</param>
            <param name="radius">the radius of the sphere</param>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingSphere.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.BoundingSphere"/> with the given center point and radius.
            </summary>
            <param name="x">the X coordinate of the center point</param>
            <param name="y">the Y coordinate of the center point</param>
            <param name="z">the Z coordinate of the center point</param>
            <param name="radius">the radius of the sphere</param>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingSphere.Contains(WCell.Util.Graphics.Vector3@)">
            <summary>
            Checks whether the <see cref="T:WCell.Util.Graphics.BoundingSphere"/> contains the given point.
            </summary>
            <param name="point">the point to check for containment.</param>
            <returns>true if the point is contained; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingSphere.Equals(WCell.Util.Graphics.BoundingSphere)">
            <summary>
            Checks equality of two spheres.
            </summary>
            <param name="other">the other sphere to compare with</param>
            <returns>true if both spheres are equal; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingSphere.Equals(System.Object)">
            <summary>
            Checks equality with another object.
            </summary>
            <param name="obj">the object to compare</param>
            <returns>true if the object is <see cref="T:WCell.Util.Graphics.BoundingSphere"/> and is equal; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.DB.LightDBMapper.AddObjectsInt``1(``0[])">
            <summary>
            Adds an Array of DataHolders where the index (int)
            within the Array is the key.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
        </member>
        <member name="M:WCell.Util.DB.LightDBMapper.AddObjectsUInt``1(``0[])">
            <summary>
            Adds an Array of DataHolders where the index (uint)
            within the Array is the key.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
        </member>
        <member name="M:WCell.Util.DB.LightDBMapper.Fetch">
            <summary>
            Fetches all sets of objects, defined through the given mapping.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.DB.LightDBMapper.Update(WCell.Util.Data.IDataHolder)">
            <summary>
            Marks this Object to be updated upon next flush
            </summary>
        </member>
        <member name="M:WCell.Util.DB.LightDBMapper.Insert(WCell.Util.Data.IDataHolder)">
            <summary>
            Marks this Object to be inserted upon next flush
            </summary>
        </member>
        <member name="M:WCell.Util.DB.LightDBMapper.Delete(WCell.Util.Data.IDataHolder)">
            <summary>
            Marks this Object to be deleted upon next flush
            </summary>
        </member>
        <member name="M:WCell.Util.DB.LightDBMapper.IgnoreUnflushedChanges">
            <summary>
            Ignores all changes that have not been commited yet.
            </summary>
        </member>
        <member name="M:WCell.Util.DB.LightDBMapper.Flush">
            <summary>
            Commits all inserts and updates to the underlying Database
            </summary>
        </member>
        <member name="M:WCell.Util.DB.LightDBMapper.ReadCacheHeader(System.IO.BinaryReader)">
            <summary>
            Reads the (semi-)unique signature of all DataHolders to prevent the worst
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="P:WCell.Util.DB.LightDBMapper.Fetched">
            <summary>
            Whether this Mapper has already fetched its contents
            </summary>
        </member>
        <member name="F:WCell.Util.Variables.VariableConfiguration`1.Definitions">
            <summary>
            Holds an array of static variable fields
            </summary>
        </member>
        <member name="T:WCell.Util.Utility">
            <summary>
            Contains miscellaneous utility method used throughout the project.
            </summary>
            <remarks>Things that can't be added as extension methods, or are too miscellaneous
            will most likely be in this class.</remarks>
        </member>
        <member name="F:WCell.Util.Utility.DefaultNameSpace">
            <summary>
            One second has 10 million system ticks (DateTime.Ticks etc)
            </summary>
        </member>
        <member name="M:WCell.Util.Utility.AddTypesToTypeMap(System.Reflection.Assembly)">
            <summary>
            Adds all non-standard Enum-types of the given Assembly to the TypeMap.
            Also caches all big enums into a dictionary to improve Lookup speed.
            </summary>
            <param name="asm"></param>
        </member>
        <member name="M:WCell.Util.Utility.GetSystemTime">
            <summary>
            Gets the system uptime.
            </summary>
            <returns>the system uptime in milliseconds</returns>
        </member>
        <member name="M:WCell.Util.Utility.GetEpochTime">
            <summary>
            Gets the time since the Unix epoch.
            </summary>
            <returns>the time since the unix epoch in seconds</returns>
        </member>
        <member name="M:WCell.Util.Utility.GetSystemTimeLong">
            <summary>
            Gets the system uptime.
            </summary>
            <remarks>
            Even though this returns a long, the original value is a 32-bit integer,
            so it will wrap back to 0 after approximately 49 and half days of system uptime.
            </remarks>
            <returns>the system uptime in milliseconds</returns>
        </member>
        <member name="M:WCell.Util.Utility.GetDateTimeToGameTime(System.DateTime)">
            <summary>
            Converts the current time and date into the time and date format of the WoW client.
            </summary>
            <returns>a packed time and date</returns>
        </member>
        <member name="M:WCell.Util.Utility.GetEpochTimeFromDT">
            <summary>
            Gets the time between the Unix epich and a specific <see cref="T:System.DateTime">time</see>.
            </summary>
            <param name="time">the end time</param>
            <returns>the time between the unix epoch and the supplied <see cref="T:System.DateTime">time</see> in seconds</returns>
        </member>
        <member name="M:WCell.Util.Utility.GetEpochTimeFromDT(System.DateTime)">
            <summary>
            Gets the time between the Unix epich and a specific <see cref="T:System.DateTime">time</see>.
            </summary>
            <param name="time">the end time</param>
            <returns>the time between the unix epoch and the supplied <see cref="T:System.DateTime">time</see> in seconds</returns>
        </member>
        <member name="M:WCell.Util.Utility.SwapReference``1(``0@,``0@)">
            <summary>
            Swaps one reference with another atomically.
            </summary>
            <typeparam name="T">the type of the reference</typeparam>
            <param name="originalRef">the original reference</param>
            <param name="newRef">the new reference</param>
        </member>
        <member name="M:WCell.Util.Utility.SwapReference``1(``0@,``0@,``0)">
            <summary>
            Swaps one reference with another atomically, and replaces the original with the given value
            </summary>
            <typeparam name="T">the type of the reference</typeparam>
            <param name="originalRef">the original reference</param>
            <param name="newRef">the new reference</param>
            <param name="replacement">the value to replace the original with</param>
        </member>
        <member name="M:WCell.Util.Utility.MoveMemory(System.Byte*,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Moves memory from one array to another.
            </summary>
            <param name="src">the pointer to the source array</param>
            <param name="srcIndex">the index to read from in the source array</param>
            <param name="dest">the destination array</param>
            <param name="destIndex">the index to write to in the destination array</param>
            <param name="len">the number of bytes to move</param>
        </member>
        <member name="M:WCell.Util.Utility.MoveMemory(System.Byte[],System.Int32,System.Byte*,System.Int32,System.Int32)">
            <summary>
            Moves memory from one array to another.
            </summary>
            <param name="src">the source array</param>
            <param name="srcIndex">the index to read from in the source array</param>
            <param name="dest">the pointer to the destination array</param>
            <param name="destIndex">the index to write to in the destination array</param>
            <param name="len">the number of bytes to move</param>
        </member>
        <member name="M:WCell.Util.Utility.Cast``1(System.Object)">
            <summary>
            Cast one thing into another
            </summary>
        </member>
        <member name="M:WCell.Util.Utility.ToString``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns the string representation of an IEnumerable (all elements, joined by comma)
            </summary>
            <param name="conj">The conjunction to be used between each elements of the collection</param>
        </member>
        <member name="M:WCell.Util.Utility.ToString``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.Object})">
            <summary>
            Returns the string representation of an IEnumerable (all elements, joined by comma)
            </summary>
            <param name="conj">The conjunction to be used between each elements of the collection</param>
        </member>
        <member name="M:WCell.Util.Utility.ToStringCol(System.Collections.ICollection,System.String)">
            <summary>
            Returns the string representation of an IEnumerable (all elements, joined by comma)
            </summary>
            <param name="conj">The conjunction to be used between each elements of the collection</param>
        </member>
        <member name="M:WCell.Util.Utility.HeadsOrTails">
            <summary>
            Random bool value
            </summary>
        </member>
        <member name="M:WCell.Util.Utility.Random(System.Int32,System.Int32)">
            <summary>
            Generates a pseudo-random number in range [from, to)
            </summary>
        </member>
        <member name="M:WCell.Util.Utility.Measure(System.String,System.Int32,System.Action)">
            <summary>
            Measures how long the given func takes to be executed repeats times
            </summary>
        </member>
        <member name="M:WCell.Util.Utility.GetMaxEnum``1">
            <summary>
            Gets the biggest value of a numeric enum
            </summary>
        </member>
        <member name="M:WCell.Util.Utility.GetSetIndices(System.UInt32[])">
            <summary>
            Creates and returns an array of all indices that are set within the given flag field.
            eg. {11000011, 11000011} would result into an array containing: 0,1,6,7,8,9,14,15
            </summary>
        </member>
        <member name="M:WCell.Util.Utility.GetSetIndices(System.UInt32)">
            <summary>
            Creates and returns an array of all indices that are set within the given flag field.
            eg. 11000011 would result into an array containing: 0,1,6,7
            </summary>
        </member>
        <member name="M:WCell.Util.Utility.GetSetIndices``1(System.UInt32)">
            <summary>
            Creates and returns an array of all indices that are set within the given flag field.
            eg. 11000011 would result into an array containing: 0,1,6,7
            </summary>
        </member>
        <member name="M:WCell.Util.Utility.Delay(System.UInt32,System.Action)">
            <summary>
            Delays the given action by the given amount of milliseconds
            </summary>
            <returns>The timer that performs the delayed call (in case that you might want to cancel earlier)</returns>
        </member>
        <member name="M:WCell.Util.Utility.IsInRange(System.Single,System.Single)">
            <summary>
            
            </summary>
        </member>
        <member name="M:WCell.Util.Utility.IsValidEMailAddress(System.String)">
            <summary>
            Checks whether the given mail-address is valid.
            </summary>
        </member>
        <member name="M:WCell.Util.Utility.GetCustomAttributes``1(System.Reflection.MemberInfo)">
            <summary>
            When overridden in a derived class, returns an array of custom attributes identified by System.Type.
            </summary>
            <typeparam name="T">The type of attribute to search for. Only attributes that are assignable to this type are returned.</typeparam>
            <param name="methodInfo"></param>
            <returns>An array of custom attributes applied to this member, or an array with zero (0) elements if no attributes have been applied.</returns>
        </member>
        <member name="M:WCell.Util.Utility.GetArrUnderlyingType(System.Type)">
            <summary>
            
            </summary>
            <param name="arrType"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Utility.GetMatchingAssemblies(System.String)">
            <summary>
            Gets all assemblies that match the given fully qualified name without version checks etc.
            </summary>
            <param name="asmName"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Utility.MergeFiles(System.String,System.String)">
            <summary>
            Writes the content of all files in the given directory to the given output file
            </summary>
            <param name="directory"></param>
            <param name="outputFile"></param>
        </member>
        <member name="M:WCell.Util.Utility.ReadLines(System.String,System.Int32,System.Boolean)">
            <summary>
            Returns up to the n first lines from the given file.
            </summary>
            <param name="fileName"></param>
            <param name="n"></param>
            <param name="ignoreEmpty"></param>
            <returns></returns>
        </member>
        <member name="T:WCell.Util.SingleEnumerator`1">
            <summary>
            Returns a single element
            </summary>
        </member>
        <member name="T:WCell.Util.Lang.Localizer`2">
            <summary>
            Localizer class that converts the elements of the Locale and Key enums to array indices to look up strings with minimal
            overhead. Values defined in supplied Enum types must all be positive and not too big.
            <typeparam name="Locale">
            int-Enum that contains a set of usable Locales. For every Locale, one XML file is created in the supplied folder to contain
            all pairs of keys their string-representations.
            </typeparam>
            <typeparam name="Key">int-Enum that contains language keys which are mapped to string values in an XML file</typeparam>
            </summary>
        </member>
        <member name="M:WCell.Util.Lang.Localizer`2.#ctor(`0,`0,System.String)">
            <summary>
            
            </summary>
            <param name="baseLocale">The locale of the translation that is the most complete (usually English)</param>
            <param name="defaultLocale"></param>
            <param name="folder"></param>
        </member>
        <member name="M:WCell.Util.Lang.Localizer`2.LoadTranslations">
            <summary>
            Not Thread-Safe!
            </summary>
        </member>
        <member name="M:WCell.Util.Lang.Localizer`2.Resync">
            <summary>
            Not Thread-Safe!
            </summary>
        </member>
        <member name="M:WCell.Util.Lang.Localizer`2.LoadTranslations(`0)">
            <summary>
            Loads all translations for the given locale from the folder
            with the name of the locale.
            </summary>
        </member>
        <member name="M:WCell.Util.Lang.Localizer`2.GetTranslations(`1)">
            <summary>
            Get all translations of the given key, in an array which is indexed by Locale.
            You can use the returned array to get a translated string, like this:
            <code>
            var translations = GetTranslations(key);
            var translation = translation[(int)mylocale];
            </code>
            </summary>
        </member>
        <member name="P:WCell.Util.Lang.Localizer`2.BaseLocale">
            <summary>
            The BaseLocale is the locale of the translation that is the most complete (usually English)
            </summary>
        </member>
        <member name="P:WCell.Util.Lang.Localizer`2.BaseTranslation">
            <summary>
            The BaseTranslation is the translation that is the most complete (usually English)
            </summary>
        </member>
        <member name="T:WCell.Util.DotNetDocs.DocEntry">
            <summary>
            
            </summary>
        </member>
        <member name="T:WCell.Util.Data.DataHolderDefinition">
            <summary>
            Contains Metadata about types that are saved/loaded to/from a persistent storage.
            </summary>
        </member>
        <member name="P:WCell.Util.Data.DataHolderDefinition.DependingFieldName">
            <summary>
            The name of the field whose values decides which Producer to use.
            </summary>
        </member>
        <member name="P:WCell.Util.Data.DataHolderDefinition.DependingField">
            <summary>
            The field whose values decides which Producer to use.
            </summary>
        </member>
        <member name="P:WCell.Util.Data.DataHolderDefinition.Type">
            <summary>
            The Type of the DataHolder-class, defined through this.
            </summary>
        </member>
        <member name="P:WCell.Util.Data.DataHolderDefinition.CacheGetter">
            <summary>
            The method that will yield all DataHolders of 
            this DataHolder's type.
            </summary>
        </member>
        <member name="T:WCell.Util.DB.TableDefinition">
            <summary>
            A table definition has an array of Columns and an array of DataFields whose indices
            correspond to each other.
            </summary>
        </member>
        <member name="F:WCell.Util.DB.TableDefinition.GetId">
            <summary>
            The handler that returns the Id (or compound Id) for each row, read from the DB.
            </summary>
        </member>
        <member name="M:WCell.Util.DB.TableDefinition.#ctor(System.String,WCell.Util.DB.Xml.PrimaryColumn[],System.Collections.Generic.Dictionary{System.String,WCell.Util.DB.Xml.ArrayConstraint},WCell.Util.Variables.VariableDefinition[])">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="primaryColumns"></param>
            <param name="arrayConstraints"></param>
        </member>
        <member name="P:WCell.Util.DB.TableDefinition.IsDefaultTable">
            <summary>
            Whether this is a DefaultTable of its <see cref="P:WCell.Util.DB.TableDefinition.MainDataHolder"/>.
            DefaultTables are the tables that contain the core data of each DataHolder.
            It is ensured that a DataHolder is only valid if it exists in all its DefaultTables.
            </summary>
        </member>
        <member name="P:WCell.Util.DB.TableDefinition.MainDataHolder">
            <summary>
            The DataHolder to which this table primarily belongs.
            It is used for variables and undefined key-references.
            </summary>
        </member>
        <member name="P:WCell.Util.DB.TableDefinition.ColumnDefinitions">
            <summary>
            Set of columns and corresponding DataFields.
            Array must not be empty and the PrimaryKey must always be the first column.
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.LazyExtensions">
            <summary>Extension methods for Lazy.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.LazyExtensions.Force``1(System.Lazy{``0})">
            <summary>Forces value creation of a Lazy instance.</summary>
            <typeparam name="T">Specifies the type of the value being lazily initialized.</typeparam>
            <param name="lazy">The Lazy instance.</param>
            <returns>The initialized Lazy instance.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.LazyExtensions.GetValueAsync``1(System.Lazy{``0})">
            <summary>Retrieves the value of a Lazy asynchronously.</summary>
            <typeparam name="T">Specifies the type of the value being lazily initialized.</typeparam>
            <param name="lazy">The Lazy instance.</param>
            <returns>A Task representing the Lazy's value.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.LazyExtensions.Create``1(``0)">
            <summary>Creates a Lazy that's already been initialized to a specified value.</summary>
            <typeparam name="T">The type of the data to be initialized.</typeparam>
            <param name="value">The value with which to initialize the Lazy instance.</param>
            <returns>The initialized Lazy.</returns>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.CancellationTokenExtensions">
            <summary>Extension methods for CancellationToken.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.CancellationTokenExtensions.CancelAndThrow(System.Threading.CancellationTokenSource)">
            <summary>Cancels a CancellationTokenSource and throws a corresponding OperationCanceledException.</summary>
            <param name="source">The source to be canceled.</param>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.CancellationTokenExtensions.CreateLinkedSource(System.Threading.CancellationToken)">
            <summary>
            Creates a CancellationTokenSource that will be canceled when the specified token has cancellation requested.
            </summary>
            <param name="token">The token.</param>
            <returns>The created CancellationTokenSource.</returns>
        </member>
        <member name="M:WCell.Util.Strings.StringNode`1.RemoveChild(System.String)">
            <summary>
            Removes and returns the direct Child with the given key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringNode`1.FindAndRemoveChild(System.String)">
            <summary>
            Removes and returns the direct Child with the given key
            </summary>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringNode`1.FindAndRemoveChild(System.String[])">
            <summary>
            Removes and returns the direct Child with the given key
            </summary>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringNode`1.FindAndRemoveChild(System.String[],System.Int32)">
            <summary>
            Removes and returns the direct Child with the given key
            </summary>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.IProducer.Produce">
            <summary>
            Creates a new object of Type T
            </summary>
        </member>
        <member name="M:WCell.Util.IProducer`1.Produce">
            <summary>
            Creates a new object of Type T
            </summary>
        </member>
        <member name="M:WCell.Util.DefaultProducer`1.Produce">
            <summary>
            Creates a new object of Type T
            </summary>
        </member>
        <member name="M:WCell.Util.DefaultArrayProducer`1.Produce">
            <summary>
            Creates a new object of Type T
            </summary>
        </member>
        <member name="T:WCell.Util.Graphics.Vector4">
            <summary>
            Defines a vector with four components.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.Vector4.X">
            <summary>
            The X component of the vector.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.Vector4.Y">
            <summary>
            The Y component of the vector.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.Vector4.Z">
            <summary>
            The Z component of the vector.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.Vector4.W">
            <summary>
            The W component of the vector.
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.Vector4.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.Vector3"/> with the given X, Y, Z and W components.
            </summary>
            <param name="x">the X component</param>
            <param name="y">the Y component</param>
            <param name="z">the Z component</param>
            <param name="w">the W component</param>
        </member>
        <member name="M:WCell.Util.Graphics.Vector4.#ctor(WCell.Util.Graphics.Vector2,System.Single,System.Single)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.Vector3"/> with the given X, Y, Z and W components.
            </summary>
            <param name="xy">the XY component</param>
            <param name="z">the Z component</param>
            <param name="w">the W component</param>
        </member>
        <member name="M:WCell.Util.Graphics.Vector4.#ctor(WCell.Util.Graphics.Vector3,System.Single)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.Vector3"/> with the given X, Y, Z and W components.
            </summary>
            <param name="xyz">the XYZ component</param>
            <param name="w">the W component</param>
        </member>
        <member name="M:WCell.Util.Graphics.Vector4.Clamp(WCell.Util.Graphics.Vector4@,WCell.Util.Graphics.Vector4@)">
            <summary>
            Clamps the values of the vector to be within a specified range.
            </summary>
            <param name="min">the minimum value</param>
            <param name="max">the maximum value</param>
            <returns>a new <see cref="T:WCell.Util.Graphics.Vector4"/> that has been clamped within the specified range</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector4.GetDistance(WCell.Util.Graphics.Vector4@)">
            <summary>
            Calculates the distance from this vector to another.
            </summary>
            <param name="point">the second <see cref="T:WCell.Util.Graphics.Vector4"/></param>
            <returns>the distance between the vectors</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector4.GetDistanceSquared(WCell.Util.Graphics.Vector4@)">
            <summary>
            Calculates the distance squared from this vector to another.
            </summary>
            <param name="point">the second <see cref="T:WCell.Util.Graphics.Vector4"/></param>
            <returns>the distance squared between the vectors</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector4.Normalize">
            <summary>
            Turns the current vector into a unit vector.
            </summary>
            <remarks>The vector becomes one unit in length and points in the same direction of the original vector.</remarks>
        </member>
        <member name="M:WCell.Util.Graphics.Vector4.Equals(WCell.Util.Graphics.Vector4)">
            <summary>
            Checks equality of two vectors.
            </summary>
            <param name="other">the other vector to compare with</param>
            <returns>true if both vectors are equal; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector4.Equals(System.Object)">
            <summary>
            Checks equality with another object.
            </summary>
            <param name="obj">the object to compare</param>
            <returns>true if the object is <see cref="T:WCell.Util.Graphics.Vector4"/> and is equal; false otherwise</returns>
        </member>
        <member name="P:WCell.Util.DB.Xml.BasicTableDefinition.ArrayConstraints">
            <summary>
            
            </summary>
        </member>
        <member name="F:WCell.Util.Data.DataHolderState.Steady">
            <summary>
            No changes
            </summary>
        </member>
        <member name="F:WCell.Util.Data.DataHolderState.JustCreated">
            <summary>
            New DataHolder
            </summary>
        </member>
        <member name="F:WCell.Util.Data.DataHolderState.Dirty">
            <summary>
            Old DataHolder with new data
            </summary>
        </member>
        <member name="T:WCell.Util.Xml.XmlUtil">
            <summary>
            TODO: Allow case-insensitive node names
            </summary>
        </member>
        <member name="F:WCell.Util.Xml.XmlUtil.DefaultCulture">
            <summary>
            We needs this for correct parsing.
            </summary>
        </member>
        <member name="M:WCell.Util.Xml.XmlUtil.EnsureCulture">
            <summary>
            Ensure a default culture, so float-comma and other values are parsed correctly on all systems
            </summary>
        </member>
        <member name="M:WCell.Util.Xml.XmlUtil.ResetCulture">
            <summary>
            Reset system-culture after parsing
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.ParallelOptionsExtensions">
            <summary>Extension methods for ParallelOptions.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.ParallelOptionsExtensions.ShallowClone(System.Threading.Tasks.ParallelOptions)">
            <summary>Copies a ParallelOptions instance to a shallow clone.</summary>
            <param name="options">The options to be cloned.</param>
            <returns>The shallow clone.</returns>
        </member>
        <member name="T:WCell.Util.Graphics.Vector3">
            <summary>
            Defines a vector with three components.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.Vector3.X">
            <summary>
            The X component of the vector.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.Vector3.Y">
            <summary>
            The Y component of the vector.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.Vector3.Z">
            <summary>
            The Z component of the vector.
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.#ctor(System.Single,System.Single)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.Vector3"/> with the given X and Y, and Z = 0.
            </summary>
            <param name="x">the X component</param>
            <param name="y">the Y component</param>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.Vector3"/> with the given X, Y and Z components.
            </summary>
            <param name="x">the X component</param>
            <param name="y">the Y component</param>
            <param name="z">the Z component</param>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.#ctor(WCell.Util.Graphics.Vector2,System.Single)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.Vector3"/> with the given X, Y, and Z components.
            </summary>
            <param name="xy">the XY component</param>
            <param name="z">the Z component</param>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.GetDistance(WCell.Util.Graphics.Vector3)">
            <summary>
            Calculates the distance from this vector to another.
            </summary>
            <param name="point">the second <see cref="T:WCell.Util.Graphics.Vector3"/></param>
            <returns>the distance between the vectors</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.GetDistance(WCell.Util.Graphics.Vector3@)">
            <summary>
            Calculates the distance from this vector to another.
            </summary>
            <param name="point">the second <see cref="T:WCell.Util.Graphics.Vector3"/></param>
            <returns>the distance between the vectors</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.DistanceSquared(WCell.Util.Graphics.Vector3)">
            <summary>
            Calculates the distance squared from this vector to another.
            </summary>
            <param name="point">the second <see cref="T:WCell.Util.Graphics.Vector3"/></param>
            <returns>the distance squared between the vectors</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.DistanceSquared(WCell.Util.Graphics.Vector3@)">
            <summary>
            Calculates the distance squared from this vector to another.
            </summary>
            <param name="point">the second <see cref="T:WCell.Util.Graphics.Vector3"/></param>
            <returns>the distance squared between the vectors</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.GetAngleTowards(WCell.Util.Graphics.Vector3)">
            <summary>
            Gets the angle between this object and the given position, in relation to the north-south axis
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.GetAngleTowards(WCell.Util.Graphics.Vector3@)">
            <summary>
            Gets the angle between this object and the given position, in relation to the north-south axis
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.GetPointXY(System.Single,System.Single,WCell.Util.Graphics.Vector3@)">
            <summary>
            Gets the Point that lies in the given angle and has dist from this Point (in the XY plane).
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.GetPointYX(System.Single,System.Single,WCell.Util.Graphics.Vector3@)">
            <summary>
            Gets the Point that lies in the given angle and has dist from this Point 
            (in the weird WoW coordinate system: X -> South, Y -> West).
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.Normalize">
            <summary>
            Turns the current vector into a unit vector.
            </summary>
            <remarks>The vector becomes one unit in length and points in the same direction of the original vector.</remarks>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.NormalizeReturnLength">
            <summary>
            Turns the current vector into a unit vector.
            </summary>
            <remarks>The vector becomes one unit in length and points in the same direction of the original vector.</remarks>
            <returns>The length of the original vector.</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.NormalizedCopy">
            <summary>
            Turns the current vector into a unit vector.
            </summary>
            <remarks>The vector becomes one unit in length and points in the same direction of the original vector.</remarks>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.ToDeltaPacked(WCell.Util.Graphics.Vector3,WCell.Util.Graphics.Vector3)">
            <summary>
            TODO: Ensure this is the correct order of packing
            </summary>
            <param name="startingVector"></param>
            <param name="firstPoint"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.Clamp(WCell.Util.Graphics.Vector3@,WCell.Util.Graphics.Vector3@)">
            <summary>
            Clamps the values of the vector to be within a specified range.
            </summary>
            <param name="min">the minimum value</param>
            <param name="max">the maximum value</param>
            <returns>a new <see cref="T:WCell.Util.Graphics.Vector3"/> that has been clamped within the specified range</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.Equals(WCell.Util.Graphics.Vector3)">
            <summary>
            Checks equality of two vectors.
            </summary>
            <param name="other">the other vector to compare with</param>
            <returns>true if both vectors are equal; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector3.Equals(System.Object)">
            <summary>
            Checks equality with another object.
            </summary>
            <param name="obj">the object to compare</param>
            <returns>true if the object is <see cref="T:WCell.Util.Graphics.Vector3"/> and is equal; false otherwise</returns>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.ParallelLinqOptions">
            <summary>Provides a grouping for common Parallel LINQ options.</summary>
        </member>
        <member name="P:WCell.Util.Threading.TaskParallel.ParallelLinqOptions.ExecutionMode">
            <summary>Gets or sets the execution mode.</summary>
        </member>
        <member name="P:WCell.Util.Threading.TaskParallel.ParallelLinqOptions.MergeOptions">
            <summary>Gets or sets the merge options.</summary>
        </member>
        <member name="P:WCell.Util.Threading.TaskParallel.ParallelLinqOptions.Ordered">
            <summary>Gets or sets whether the query should retain ordering.</summary>
        </member>
        <member name="T:WCell.Util.Synchronization.SimpleLockWrapper">
            <summary>
            When used with the "using" statement, does pretty much the same as the lock statement.
            But we use this class so we can easily change the implementation, if required.
            </summary>
        </member>
        <member name="M:WCell.Util.FileStreamTarget.Open">
            <summary>
            Opens a new StreamWriter to the given Path if not already opened.
            </summary>
        </member>
        <member name="T:WCell.Util.Graphics.Vector2">
            <summary>
            Defines a vector with two components.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.Vector2.X">
            <summary>
            The X component of the vector.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.Vector2.Y">
            <summary>
            The Y component of the vector.
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.Vector2.#ctor(System.Single,System.Single)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.Vector2"/> with the given X and Y components.
            </summary>
            <param name="x">the X component</param>
            <param name="y">the Y component</param>
        </member>
        <member name="M:WCell.Util.Graphics.Vector2.Clamp(WCell.Util.Graphics.Vector2@,WCell.Util.Graphics.Vector2@)">
            <summary>
            Clamps the values of the vector to be within a specified range.
            </summary>
            <param name="min">the minimum value</param>
            <param name="max">the maximum value</param>
            <returns>a new <see cref="T:WCell.Util.Graphics.Vector2"/> that has been clamped within the specified range</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector2.GetDistance(WCell.Util.Graphics.Vector2@)">
            <summary>
            Calculates the distance from this vector to another.
            </summary>
            <param name="point">the second <see cref="T:WCell.Util.Graphics.Vector2"/></param>
            <returns>the distance between the vectors</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector2.GetDistanceSquared(WCell.Util.Graphics.Vector2@)">
            <summary>
            Calculates the distance squared from this vector to another.
            </summary>
            <param name="point">the second <see cref="T:WCell.Util.Graphics.Vector2"/></param>
            <returns>the distance squared between the vectors</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector2.Subtract(WCell.Util.Graphics.Vector2@,WCell.Util.Graphics.Vector2@,WCell.Util.Graphics.Vector2@)">
            <summary>
            Subtracts vector b from vector a.
            </summary>
            <param name="a">The vector to subtract from.</param>
            <param name="b">The subtracting vector.</param>
            <param name="result">A Vector2 filled with the result of (a - b).</param>
        </member>
        <member name="M:WCell.Util.Graphics.Vector2.Normalize">
            <summary>
            Turns the current vector into a unit vector.
            </summary>
            <remarks>The vector becomes one unit in length and points in the same direction of the original vector.</remarks>
        </member>
        <member name="M:WCell.Util.Graphics.Vector2.Equals(WCell.Util.Graphics.Vector2)">
            <summary>
            Checks equality of two vectors.
            </summary>
            <param name="other">the other vector to compare with</param>
            <returns>true if both vectors are equal; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.Graphics.Vector2.Equals(System.Object)">
            <summary>
            Checks equality with another object.
            </summary>
            <param name="obj">the object to compare</param>
            <returns>true if the object is <see cref="T:WCell.Util.Graphics.Vector2"/> and is equal; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.Data.INestedDataField.GetTargetObject(WCell.Util.Data.IDataHolder)">
            <summary>
            
            </summary>
            <param name="rootObject"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Data.DataField.GetTargetObject(WCell.Util.Data.IDataHolder)">
            <summary>
            
            </summary>
            <param name="rootObject"></param>
            <returns></returns>
        </member>
        <member name="T:WCell.Util.IIndexedGetterSetter">
            <summary>
            The IPropertyAccessor interface defines a property
            accessor.
            </summary>
        </member>
        <member name="M:WCell.Util.IIndexedGetterSetter.Get(System.Object,System.Int32)">
            <summary>
            </summary>
            <returns>Value.</returns>
        </member>
        <member name="M:WCell.Util.IIndexedGetterSetter.Set(System.Object,System.Int32,System.Object)">
            <summary>
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:WCell.Util.Data.ArrayDataField.Get(System.Object,System.Int32)">
            <summary>
            Returns the object at the given index (might be null).
            </summary>
            <param name="arrayContainer"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:WCell.Util.Data.ArrayDataField.Length">
            <summary>
            The minimal required length of this Array
            </summary>
        </member>
        <member name="T:WCell.Util.IGetterSetter">
            <summary>
            </summary>
        </member>
        <member name="M:WCell.Util.IGetterSetter.Get(System.Object)">
            <summary>
            </summary>
            <returns>Value.</returns>
        </member>
        <member name="M:WCell.Util.IGetterSetter.Set(System.Object,System.Object)">
            <summary>
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="T:WCell.Util.BoxExtensions">
            <summary>
             Adds functonality to the BoundingBox class
            </summary>
        </member>
        <member name="M:WCell.Util.BoxExtensions.Center(WCell.Util.Graphics.BoundingBox)">
            <summary>
            Calculates the vector at the center of the box
            </summary>
            <returns>A Vector3 that points to the center of the BoundingBox.</returns>
        </member>
        <member name="M:WCell.Util.BoxExtensions.Extents(WCell.Util.Graphics.BoundingBox)">
            <summary>
            Returns Box.Max in Box coordinates
            </summary>
        </member>
        <member name="M:WCell.Util.IOExtensions.ReadCString(System.IO.BinaryReader)">
            <summary>
            Reads a C-style null-terminated string from the current stream.
            </summary>
            <param name="binReader">the extended <see cref="T:System.IO.BinaryReader"/> instance</param>
            <returns>the string being reader</returns>
        </member>
        <member name="M:WCell.Util.Code.CodeFileWriter.ExecuteSafely(System.Action)">
            <summary>
            Executes the given action. 
            If an Exception is raised, the Exception handler will be called and the file will be reverted.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:WCell.Util.Code.CodeFileWriter.WriteCTor(System.Action)">
            <summary>
            Public Default CTor
            </summary>
            <param name="bodyWriter"></param>
        </member>
        <member name="M:WCell.Util.Code.CodeFileWriter.WriteStaticCTor(System.Action)">
            <summary>
            Static CTor
            </summary>
            <param name="bodyWriter"></param>
        </member>
        <member name="M:WCell.Util.Code.CodeFileWriter.Finish">
            <summary>
            Closes all remaining brackets
            </summary>
        </member>
        <member name="P:WCell.Util.Code.CodeFileWriter.RaisedException">
            <summary>
            Whether an Exception was raised during writing of the file.
            </summary>
        </member>
        <member name="P:WCell.Util.Code.CodeFileWriter.Backup">
            <summary>
            The content of the file before (or null if there was none).
            </summary>
        </member>
        <member name="T:WCell.Util.INamed">
            <summary>
            Defines an object with a name.
            </summary>
        </member>
        <member name="T:WCell.Util.ReflectionUtil.MemberAccessor`1">
            <summary>
            
            </summary>
            <typeparam name="U">The type of the User objects</typeparam>
        </member>
        <member name="M:WCell.Util.ReflectionUtil.MemberAccessor`1.GetMembers(`0,System.Object,System.String,System.Object@)">
            <summary>
            Returns all members of an object with the given name (if character can use it)
            </summary>
        </member>
        <member name="M:WCell.Util.ReflectionUtil.MemberAccessor`1.GetMembers(`0,System.Object,System.String,System.Type,System.Object@)">
            <summary>
            Returns all members of an object with the given name (if character can access all holders in the chain)
            </summary>
        </member>
        <member name="M:WCell.Util.ReflectionUtil.MemberAccessor`1.SetPropValue(`0,System.Object,System.String,System.String)">
            <summary>
            Sets a property on the given object.
            </summary>
        </member>
        <member name="M:WCell.Util.ReflectionUtil.MemberAccessor`1.GetPropValue(`0,System.Object,System.String@,System.Object@)">
            <summary>
            Returns the value of a property-chain if user == null or user may read the given prop.
            </summary>
        </member>
        <member name="M:WCell.Util.ReflectionUtil.MemberAccessor`1.GetPropValue(`0,System.Object,System.String@,System.Type,System.Object@)">
            <summary>
            Returns the value of a property-chain if user == null or user may read the given prop.
            </summary>
        </member>
        <member name="T:WCell.Util.DB.DataHolderTableMapping">
            <summary>
            Defines the relation between a set of DataHolder and the tables that belong to them.
            This is a many-to-many relationship:
            One DataHolder can use multiple tables and multiple tables can be used by the same DataHolder.
            It is ensured that all default-tables have a lower index than non-default ones in the <see cref="F:WCell.Util.DB.DataHolderTableMapping.TableDefinitions"/>-array.
            </summary>
        </member>
        <member name="F:WCell.Util.DB.DataHolderTableMapping.TableDefinitions">
            <summary>
            All Tables that are used by all <see cref="F:WCell.Util.DB.DataHolderTableMapping.DataHolderDefinitions"/>.
            It is ensured that all default-tables have a lower index than non-default ones.
            </summary>
        </member>
        <member name="M:WCell.Util.Data.BinaryPersistors.GetPersistor(WCell.Util.Data.IDataField)">
            <summary>
            Returns null if its a String field
            </summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="P:WCell.Util.Data.StringPersistor.BinaryLength">
            <summary>
            Redundant
            </summary>
        </member>
        <member name="F:WCell.Util.Variables.VariableAttribute.IsFileOnly">
            <summary>
            If set to false, cannot get or set this variable through any command
            </summary>
        </member>
        <member name="M:WCell.Util.AppUtil.SetConsoleCtrlHandler(WCell.Util.AppUtil.ConsoleCtrlHandler,System.Boolean)">
            <summary>
            see: http://geekswithblogs.net/mrnat/archive/2004/09/23/11594.aspx
            </summary>
            <param name="consoleCtrlHandler"></param>
            <param name="Add"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.AppUtil.UnhookAll">
            <summary>
            Removes all previously added hooks
            </summary>
        </member>
        <member name="M:WCell.Util.AppUtil.AddApplicationExitHandler(System.Action)">
            <summary>
            Adds an action that will be executed when the Application exists.
            </summary>
            <param name="action"></param>
        </member>
        <member name="P:WCell.Util.AppUtil.IsWindows2000OrNewer">
            <summary>
            Gets a value indicating if the operating system is a Windows 2000 or a newer one.
            </summary>
        </member>
        <member name="P:WCell.Util.AppUtil.IsWindowsXpOrNewer">
            <summary>
            Gets a value indicating if the operating system is a Windows XP or a newer one.
            </summary>
        </member>
        <member name="P:WCell.Util.AppUtil.IsWindowsVistaOrNewer">
            <summary>
            Gets a value indicating if the operating system is a Windows Vista or a newer one.
            </summary>
        </member>
        <member name="T:WCell.Util.AppUtil.ConsoleCtrlHandler">
            <summary>
            Needed for <see cref="M:WCell.Util.AppUtil.SetConsoleCtrlHandler(WCell.Util.AppUtil.ConsoleCtrlHandler,System.Boolean)"/>
            </summary>
            <param name="CtrlType"></param>
            <returns></returns>
        </member>
        <member name="T:WCell.Util.AppUtil.CtrlTypes">
            <summary>
            Needed for <see cref="M:WCell.Util.AppUtil.SetConsoleCtrlHandler(WCell.Util.AppUtil.ConsoleCtrlHandler,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:WCell.Util.DynamicAccess.AccessorMgr.GetOrCreateAccessor(System.Type,System.Reflection.PropertyInfo)">
            <summary>
            Copies all public properties that have a setter and a getter and exist in the types of both objects from input to output.
            Ignores all properties that have the <see cref="T:WCell.Util.DynamicAccess.DontCopyAttribute"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.EnumUtil.TryParse``1(System.String,``0@)">
            <summary>
            TODO: Put big enums in dictionaries
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:WCell.Util.Graphics.Point2D">
            <summary>
            Fixed 2D point (using integers for components)
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.TaskExtensions">
            <summary>Extensions methods for Task.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.ContinueWith(System.Threading.Tasks.Task,System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskFactory)">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="continuationAction">The continuation action.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.ContinueWith``1(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskFactory)">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="continuationFunction">The continuation function.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.ContinueWith``1(System.Threading.Tasks.Task{``0},System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskFactory{``0})">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="continuationAction">The continuation action.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.ContinueWith``2(System.Threading.Tasks.Task{``0},System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskFactory{``0})">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="continuationFunction">The continuation function.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.ToAsync(System.Threading.Tasks.Task,System.AsyncCallback,System.Object)">
            <summary>
            Creates a Task that represents the completion of another Task, and 
            that schedules an AsyncCallback to run upon completion.
            </summary>
            <param name="task">The antecedent Task.</param>
            <param name="callback">The AsyncCallback to run.</param>
            <param name="state">The object state to use with the AsyncCallback.</param>
            <returns>The new task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.ToAsync``1(System.Threading.Tasks.Task{``0},System.AsyncCallback,System.Object)">
            <summary>
            Creates a Task that represents the completion of another Task, and 
            that schedules an AsyncCallback to run upon completion.
            </summary>
            <param name="task">The antecedent Task.</param>
            <param name="callback">The AsyncCallback to run.</param>
            <param name="state">The object state to use with the AsyncCallback.</param>
            <returns>The new task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.IgnoreExceptions(System.Threading.Tasks.Task)">
            <summary>Suppresses default exception handling of a Task that would otherwise reraise the exception on the finalizer thread.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.IgnoreExceptions``1(System.Threading.Tasks.Task{``0})">
            <summary>Suppresses default exception handling of a Task that would otherwise reraise the exception on the finalizer thread.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.FailFastOnException(System.Threading.Tasks.Task)">
            <summary>Fails immediately when an exception is encountered.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.FailFastOnException``1(System.Threading.Tasks.Task{``0})">
            <summary>Fails immediately when an exception is encountered.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.PropagateExceptions(System.Threading.Tasks.Task)">
            <summary>Propagates any exceptions that occurred on the specified task.</summary>
            <param name="task">The Task whose exceptions are to be propagated.</param>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.PropagateExceptions(System.Threading.Tasks.Task[])">
            <summary>Propagates any exceptions that occurred on the specified tasks.</summary>
            <param name="task">The Tassk whose exceptions are to be propagated.</param>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.AttachToParent(System.Threading.Tasks.Task)">
            <summary>
            Ensures that a parent task can't transition into a completed state
            until the specified task has also completed, even if it's not
            already a child task.
            </summary>
            <param name="task">The task to attach to the current task as a child.</param>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.WithTimeout(System.Threading.Tasks.Task,System.TimeSpan)">
            <summary>Creates a new Task that mirrors the supplied task but that will be canceled after the specified timeout.</summary>
            <param name="task">The task.</param>
            <param name="timeout">The timeout.</param>
            <returns>The new Task that may time out.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.WithTimeout``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
            <summary>Creates a new Task that mirrors the supplied task but that will be canceled after the specified timeout.</summary>
            <typeparam name="TResult">Specifies the type of data contained in the task.</typeparam>
            <param name="task">The task.</param>
            <param name="timeout">The timeout.</param>
            <returns>The new Task that may time out.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})">
            <summary>Creates an IObservable that represents the completion of a Task.</summary>
            <typeparam name="TResult">Specifies the type of data returned by the Task.</typeparam>
            <param name="task">The Task to be represented as an IObservable.</param>
            <returns>An IObservable that represents the completion of the Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskExtensions.WaitForCompletionStatus(System.Threading.Tasks.Task)">
            <summary>Waits for the task to complete execution, returning the task's final status.</summary>
            <param name="task">The task for which to wait.</param>
            <returns>The completion status of the task.</returns>
            <remarks>Unlike Wait, this method will not throw an exception if the task ends in the Faulted or Canceled state.</remarks>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.TaskExtensions.TaskObservable`1">
            <summary>An implementation of IObservable that wraps a Task.</summary>
            <typeparam name="TResult">The type of data returned by the task.</typeparam>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.TaskExtensions.CancelOnDispose">
            <summary>Translate a call to IDisposable.Dispose to a CancellationTokenSource.Cancel.</summary>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.TaskCompletionSourceExtensions">
            <summary>Extension methods for TaskCompletionSource.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskCompletionSourceExtensions.SetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task)">
            <summary>Transfers the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="resultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transfered.</param>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskCompletionSourceExtensions.SetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task{``0})">
            <summary>Transfers the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="resultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transfered.</param>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskCompletionSourceExtensions.TrySetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task)">
            <summary>Attempts to transfer the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="resultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transfered.</param>
            <returns>Whether the transfer could be completed.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskCompletionSourceExtensions.TrySetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task{``0})">
            <summary>Attempts to transfer the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="resultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transfered.</param>
            <returns>Whether the transfer could be completed.</returns>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions">
            <summary>Extension methods for BlockingCollection.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.GetConsumingPartitioner``1(System.Collections.Concurrent.BlockingCollection{``0})">
            <summary>
            Gets a partitioner for a BlockingCollection that consumes and yields the contents of the BlockingCollection.</summary>
            <typeparam name="T">Specifies the type of data in the collection.</typeparam>
            <param name="collection">The collection for which to create a partitioner.</param>
            <returns>A partitioner that completely consumes and enumerates the contents of the collection.</returns>
            <remarks>
            Using this partitioner with a Parallel.ForEach loop or with PLINQ eliminates the need for those
            constructs to do any additional locking.  The only synchronization in place is that used by the
            BlockingCollection internally.
            </remarks>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.AddFromEnumerable``1(System.Collections.Concurrent.BlockingCollection{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>Adds the contents of an enumerable to the BlockingCollection.</summary>
            <typeparam name="T">Specifies the type of the elements in the collection.</typeparam>
            <param name="target">The target BlockingCollection to be augmented.</param>
            <param name="source">The source enumerable containing the data to be added.</param>
            <param name="completeAddingWhenDone">
            Whether to mark the target BlockingCollection as complete for adding when 
            all elements of the source enumerable have been transfered.
            </param>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.AddFromObservable``1(System.Collections.Concurrent.BlockingCollection{``0},System.IObservable{``0},System.Boolean)">
            <summary>Adds the contents of an observable to the BlockingCollection.</summary>
            <typeparam name="T">Specifies the type of the elements in the collection.</typeparam>
            <param name="target">The target BlockingCollection to be augmented.</param>
            <param name="source">The source observable containing the data to be added.</param>
            <param name="completeAddingWhenDone">
            Whether to mark the target BlockingCollection as complete for adding when 
            all elements of the source observable have been transfered.
            </param>
            <returns>An IDisposable that may be used to cancel the transfer.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.ToProducerConsumerCollection``1(System.Collections.Concurrent.BlockingCollection{``0})">
            <summary>Creates an IProducerConsumerCollection-facade for a BlockingCollection instance.</summary>
            <typeparam name="T">Specifies the type of the elements in the collection.</typeparam>
            <param name="collection">The BlockingCollection.</param>
            <returns>
            An IProducerConsumerCollection that wraps the provided BlockingCollection.
            </returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.ToProducerConsumerCollection``1(System.Collections.Concurrent.BlockingCollection{``0},System.Int32)">
            <summary>Creates an IProducerConsumerCollection-facade for a BlockingCollection instance.</summary>
            <typeparam name="T">Specifies the type of the elements in the collection.</typeparam>
            <param name="collection">The BlockingCollection.</param>
            <param name="millisecondsTimeout">-1 for infinite blocking add and take operations. 0 for non-blocking, 1 or greater for blocking with timeout.</param>
            <returns>An IProducerConsumerCollection that wraps the provided BlockingCollection.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.ToProducerConsumerCollection``1(System.Collections.Concurrent.BlockingCollection{``0},System.Int32,System.Threading.CancellationToken)">
            <summary>Creates an IProducerConsumerCollection-facade for a BlockingCollection instance.</summary>
            <typeparam name="T">Specifies the type of the elements in the collection.</typeparam>
            <param name="collection">The BlockingCollection.</param>
            <param name="millisecondsTimeout">-1 for infinite blocking add and take operations. 0 for non-blocking, 1 or greater for blocking with timeout.</param>
            <param name="cancellationToken">The CancellationToken to use for any blocking operations.</param>
            <returns>An IProducerConsumerCollection that wraps the provided BlockingCollection.</returns>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.BlockingCollectionPartitioner`1">
            <summary>Provides a partitioner that consumes a blocking collection and yields its contents.</summary>
            <typeparam name="T">Specifies the type of data in the collection.</typeparam>
        </member>
        <member name="F:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.BlockingCollectionPartitioner`1._collection">
            <summary>The target collection.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.BlockingCollectionPartitioner`1.#ctor(System.Collections.Concurrent.BlockingCollection{`0})">
            <summary>Initializes the partitioner.</summary>
            <param name="collection">The collection to be enumerated and consumed.</param>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.BlockingCollectionPartitioner`1.GetPartitions(System.Int32)">
            <summary>Partitions the underlying collection into the given number of partitions.</summary>
            <param name="partitionCount">The number of partitions to create.</param>
            <returns>A list containing partitionCount enumerators.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.BlockingCollectionPartitioner`1.GetDynamicPartitions">
            <summary>
            Creates an object that can partition the underlying collection into a variable number of partitions.
            </summary>
            <returns>An object that can create partitions over the underlying data source.</returns>
        </member>
        <member name="P:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.BlockingCollectionPartitioner`1.SupportsDynamicPartitions">
            <summary>Gets whether additional partitions can be created dynamically.</summary>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.BlockingCollectionExtensions.ProducerConsumerWrapper`1">
            <summary>Provides a producer-consumer collection facade for a BlockingCollection.</summary>
            <typeparam name="T">Specifies the type of the elements in the collection.</typeparam>
        </member>
        <member name="T:WCell.Util.Strings.StringStream">
            <summary>
            Wraps a string for convinient string parsing.
            It is using an internal position for the given string so you can read
            continuesly the next part.
            
            TODO: Make it an actual stream
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.Reset">
            <summary>
            Resets the position to the beginning.
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.Skip(System.Int32)">
            <summary>
            Increases the position by the given count.
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextLong">
            <returns><code>NextLong(-1, \" \")</code></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextLong(System.Int64)">
            <returns><code>NextLong(defaultVal, \" \")</code></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextLong(System.Int64,System.String)">
            <returns>The next word as long.</returns>
            <param name="defaultVal">What should be returned if the next word cannot be converted into a long.</param>
            <param name="separator">What the next word should be seperated by.</param>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextInt">
            <returns><code>NextInt(-1, \" \")</code></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextInt(System.Int32)">
            <returns><code>NextInt(defaultVal, \" \")</code></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextInt(System.Int32,System.String)">
            <returns>The next word as int.</returns>
            <param name="defaultVal">What should be returned if the next word cannot be converted into an int.</param>
            <param name="separator">What the next word should be seperated by.</param>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextUInt">
            <returns><code>NextUInt(-1, \" \")</code></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextUInt(System.UInt32)">
            <returns><code>NextUInt(defaultVal, \" \")</code></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextUInt(System.UInt32,System.String)">
            <returns>The next word as uint.</returns>
            <param name="defaultVal">What should be returned if the next word cannot be converted into an int.</param>
            <param name="separator">What the next word should be seperated by.</param>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextFloat">
            <returns><code>NextInt(-1, \" \")</code></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextFloat(System.Single)">
            <returns><code>NextInt(defaultVal, \" \")</code></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextFloat(System.Single,System.String)">
            <returns>The next word as int.</returns>
            <param name="defaultVal">What should be returned if the next word cannot be converted into an int.</param>
            <param name="separator">What the next word should be seperated by.</param>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextEnum``1(``0)">
            <summary>
            Calls <code>NextEnum(" ")</code>.
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextWord">
            <summary>
            Calls <code>NextWord(" ")</code>.
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextWord(System.String)">
            <summary>
            Moves the position behind the next word in the string, seperated by <code>seperator</code> and returns the word.
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextWords(System.Int32)">
            <returns><code>NextWords(count, \" \")</code></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextString(System.String@,System.String)">
            <summary>
            Read the next quoted string or a single word, separated by the given separator
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextQuotedString">
            <summary>
            Reads a quoted string.
            Returns an empty string if the next character is not a quotation mark.
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextTimeSpan">
            <summary>
            -[smhdw] [seconds] [minutes] [hours] [days] [weeks]
            </summary>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextWords(System.Int32,System.String)">
            <returns>The next <code>count</code> word seperated by <code>seperator</code> as a string.</returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextWordsArray(System.Int32,System.String)">
            <returns>The next <code>count</code> word seperated by <code>seperator</code> as an array of strings.</returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.RemainingWords">
            <summary>
            Calls <code>RemainingWords(" ")</code>
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.ConsumeSpace">
            <returns><code>Consume(' ')</code></returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.SkipWord">
            <summary>
            Calls <code>SkipWord(" ")</code>.
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.SkipWord(System.String)">
            <summary>
            Skips the next word, seperated by the given seperator.
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.SkipWords(System.Int32)">
            <summary>
            Calls <code>SkipWords(count, " ")</code>.
            </summary>
            <param name="count">The amount of words to be skipped.</param>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.SkipWords(System.Int32,System.String)">
            <summary>
            Skips <code>count</code> words, seperated by the given seperator.
            </summary>
            <param name="count">The amount of words to be skipped.</param>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.Consume(System.String)">
            <summary>
            Consume a whole string, as often as it occurs.
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.Consume(System.Char)">
            <summary>
            Ignores all directly following characters that are equal to <code>c</code>.
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.Consume(System.Char,System.Int32)">
            <summary>
            Ignores a maximum of <code>amount</code> characters that are equal to <code>c</code>.
            </summary>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.ConsumeNext(System.Char)">
            <summary>
            Consumes the next character, if it equals <code>c</code>.
            </summary>
            <returns>whether the character was equal to <code>c</code> (and thus has been deleted)</returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.Contains(System.String)">
            <returns>whether or not the remainder contains the given string.</returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.Contains(System.Char)">
            <returns>whether or not the remainder contains the given char.</returns>
        </member>
        <member name="M:WCell.Util.Strings.StringStream.NextModifiers">
            <summary>
            Reads the next word as string of modifiers. 
            Modifiers are a string (usually representing a set of different modifiers per char), preceeded by a -.
            </summary>
            <remarks>Doesn't do anything if the next word does not start with a -.</remarks>
            <returns>The set of flags without the - or "" if none found</returns>
        </member>
        <member name="P:WCell.Util.Strings.StringStream.HasNext">
            <summary>
            Indicates whether we did not reach the end yet.
            </summary>
        </member>
        <member name="P:WCell.Util.Strings.StringStream.Position">
            <summary>
            The position within the initial string.
            </summary>
        </member>
        <member name="P:WCell.Util.Strings.StringStream.Length">
            <summary>
            The remaining length (from the current position until the end).
            </summary>
        </member>
        <member name="P:WCell.Util.Strings.StringStream.Remainder">
            <summary>
            The remaining string (from the current position until the end).
            </summary>
        </member>
        <member name="P:WCell.Util.Strings.StringStream.String">
            <summary>
            The wrapped string.
            </summary>
        </member>
        <member name="P:WCell.Util.Strings.StringStream.Item(System.Int32)">
            <summary>
            [Not implemented]
            </summary>
        </member>
        <member name="F:WCell.Util.MathUtil.PI">
            <summary>
            PI with less precision but faster
            </summary>
        </member>
        <member name="F:WCell.Util.MathUtil.TwoPI">
            <summary>
            PI with less precision but faster
            </summary>
        </member>
        <member name="F:WCell.Util.MathUtil.E">
            <summary>
            E with less precision but faster
            </summary>
        </member>
        <member name="F:WCell.Util.MathUtil.RadiansPerDegree">
            <summary>
            1 degree = 0.0174532925 radians
            </summary>
        </member>
        <member name="M:WCell.Util.MathUtil.CeilingInt(System.Single)">
            <summary>
            TODO: Implement faster version
            </summary>
        </member>
        <member name="M:WCell.Util.MathUtil.Round(System.Single)">
            <summary>
            Unprecise but fast (don't use for values greater or smaller than integer range (+-2 billion))
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.MathUtil.Divide(System.UInt32,System.UInt32)">
            <summary>
            Divides and returns a rounded result
            </summary>
            <param name="nominator"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.MathUtil.ClampMinMax(System.Int16,System.Int16,System.Int16)">
            <summary>
            Clamps a number by an upper and lower limit.
            </summary>
            <remarks>This method effectively lets you bound a value between two values, as in
            if you have bounds of 0 - 100, and a number is 130, it'll clamp it to 100, and vise versa.</remarks>
            <param name="value">the value to clamp</param>
            <param name="min">the minimum bound</param>
            <param name="max">the maximum bound</param>
            <returns>either the original number, or a clamped number based on the upper/lower bounds</returns>
        </member>
        <member name="M:WCell.Util.MathUtil.ClampMinMax(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Clamps a number by an upper and lower limit.
            </summary>
            <remarks>This method effectively lets you bound a value between two values, as in
            if you have bounds of 0 - 100, and a number is 130, it'll clamp it to 100, and vise versa.</remarks>
            <param name="value">the value to clamp</param>
            <param name="min">the minimum bound</param>
            <param name="max">the maximum bound</param>
            <returns>either the original number, or a clamped number based on the upper/lower bounds</returns>
        </member>
        <member name="M:WCell.Util.MathUtil.ClampMinMax(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamps a number by an upper and lower limit.
            </summary>
            <remarks>This method effectively lets you bound a value between two values, as in
            if you have bounds of 0 - 100, and a number is 130, it'll clamp it to 100, and vise versa.</remarks>
            <param name="value">the value to clamp</param>
            <param name="min">the minimum bound</param>
            <param name="max">the maximum bound</param>
            <returns>either the original number, or a clamped number based on the upper/lower bounds</returns>
        </member>
        <member name="M:WCell.Util.MathUtil.ClampMinMax(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Clamps a number by an upper and lower limit.
            </summary>
            <remarks>This method effectively lets you bound a value between two values, as in
            if you have bounds of 0 - 100, and a number is 130, it'll clamp it to 100, and vise versa.</remarks>
            <param name="value">the value to clamp</param>
            <param name="min">the minimum bound</param>
            <param name="max">the maximum bound</param>
            <returns>either the original number, or a clamped number based on the upper/lower bounds</returns>
        </member>
        <member name="M:WCell.Util.MathUtil.ClampMinMax(System.Int64,System.Int64,System.Int64)">
            <summary>
            Clamps a number by an upper and lower limit.
            </summary>
            <remarks>This method effectively lets you bound a value between two values, as in
            if you have bounds of 0 - 100, and a number is 130, it'll clamp it to 100, and vise versa.</remarks>
            <param name="value">the value to clamp</param>
            <param name="min">the minimum bound</param>
            <param name="max">the maximum bound</param>
            <returns>either the original number, or a clamped number based on the upper/lower bounds</returns>
        </member>
        <member name="M:WCell.Util.MathUtil.ClampMinMax(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Clamps a number by an upper and lower limit.
            </summary>
            <remarks>This method effectively lets you bound a value between two values, as in
            if you have bounds of 0 - 100, and a number is 130, it'll clamp it to 100, and vise versa.</remarks>
            <param name="value">the value to clamp</param>
            <param name="min">the minimum bound</param>
            <param name="max">the maximum bound</param>
            <returns>either the original number, or a clamped number based on the upper/lower bounds</returns>
        </member>
        <member name="M:WCell.Util.MathUtil.ClampMinMax(System.Single,System.Single,System.Single)">
            <summary>
            Clamps a number by an upper and lower limit.
            </summary>
            <remarks>This method effectively lets you bound a value between two values, as in
            if you have bounds of 0 - 100, and a number is 130, it'll clamp it to 100, and vise versa.</remarks>
            <param name="value">the value to clamp</param>
            <param name="min">the minimum bound</param>
            <param name="max">the maximum bound</param>
            <returns>either the original number, or a clamped number based on the upper/lower bounds</returns>
        </member>
        <member name="M:WCell.Util.MathUtil.ClampMinMax(System.Double,System.Double,System.Double)">
            <summary>
            Clamps a number by an upper and lower limit.
            </summary>
            <remarks>This method effectively lets you bound a value between two values, as in
            if you have bounds of 0 - 100, and a number is 130, it'll clamp it to 100, and vise versa.</remarks>
            <param name="value">the value to clamp</param>
            <param name="min">the minimum bound</param>
            <param name="max">the maximum bound</param>
            <returns>either the original number, or a clamped number based on the upper/lower bounds</returns>
        </member>
        <member name="M:WCell.Util.MathUtil.ClampMinMax(System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Clamps a number by an upper and lower limit.
            </summary>
            <remarks>This method effectively lets you bound a value between two values, as in
            if you have bounds of 0 - 100, and a number is 130, it'll clamp it to 100, and vise versa.</remarks>
            <param name="value">the value to clamp</param>
            <param name="min">the minimum bound</param>
            <param name="max">the maximum bound</param>
            <returns>either the original number, or a clamped number based on the upper/lower bounds</returns>
        </member>
        <member name="M:WCell.Util.MathUtil.CountBits(System.Int32)">
            <summary>
            Counts 1's , linear in the number of 1's in the given number
            </summary>
        </member>
        <member name="T:WCell.Util.Collections.IdQueue">
            <summary>
            Allows reusable uint Ids
            </summary>
        </member>
        <member name="P:WCell.Util.DB.Xml.DataFieldDefinition.Name">
            <summary>
            The name of the DataField it belongs to
            </summary>
        </member>
        <member name="P:WCell.Util.DB.Xml.BaseFieldArrayDefinition.Pattern">
            <summary>
            Specify an array through a pattern where the <see cref="T:WCell.Util.DB.Patterns"/> 
            class defines possible constants.
            </summary>
        </member>
        <member name="P:WCell.Util.DB.Xml.BaseFieldArrayDefinition.Offset">
            <summary>
            Offset for pattern
            </summary>
        </member>
        <member name="P:WCell.Util.DB.Xml.BaseFieldArrayDefinition.ExpliciteColumns">
            <summary>
            An alternative way:
            Specify all columns of the Array explicitely
            </summary>
        </member>
        <member name="T:WCell.Util.DB.Xml.FlatArrayFieldDefinition">
            <summary>
            Flat array
            </summary>
        </member>
        <member name="T:WCell.Util.DB.Xml.IFlatField">
            <summary>
            Indicates that all parts of this field are in the table with the given Name.
            </summary>
        </member>
        <member name="T:WCell.Util.Data.IDataHolder">
            <summary>
            Marks a Type to be persistent.
            Each implementing class can have an optional static method
            <![CDATA[IEnumerable<IDataHolder>GetAllDataHolders()]]>
            that is used for caching
            </summary>
        </member>
        <member name="P:WCell.Util.DB.BaseDataColumn.ColumnName">
            <summary>
            The name of the Column
            </summary>
        </member>
        <member name="T:WCell.Util.Collections.LockfreeQueue`1">
            <summary>
            Represents a lock-free, thread-safe, first-in, first-out collection of objects.
            </summary>
            <typeparam name="T">specifies the type of the elements in the queue</typeparam>
            <remarks>Enumeration and clearing are not thread-safe.</remarks>
        </member>
        <member name="M:WCell.Util.Collections.LockfreeQueue`1.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:WCell.Util.Collections.LockfreeQueue`1.Enqueue(`0)">
            <summary>
            Adds an object to the end of the queue.
            </summary>
            <param name="item">the object to add to the queue</param>
        </member>
        <member name="M:WCell.Util.Collections.LockfreeQueue`1.TryDequeue(`0@)">
            <summary>
            Removes and returns the object at the beginning of the queue.
            </summary>
            <param name="item">
            when the method returns, contains the object removed from the beginning of the queue, 
            if the queue is not empty; otherwise it is the default value for the element type
            </param>
            <returns>
            true if an object from removed from the beginning of the queue; 
            false if the queue is empty
            </returns>
        </member>
        <member name="M:WCell.Util.Collections.LockfreeQueue`1.Dequeue">
            <summary>
            Removes and returns the object at the beginning of the queue.
            </summary>
            <returns>the object that is removed from the beginning of the queue</returns>
        </member>
        <member name="M:WCell.Util.Collections.LockfreeQueue`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the queue.
            </summary>
            <returns>an enumerator for the queue</returns>
        </member>
        <member name="M:WCell.Util.Collections.LockfreeQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the queue.
            </summary>
            <returns>an enumerator for the queue</returns>
        </member>
        <member name="M:WCell.Util.Collections.LockfreeQueue`1.Clear">
            <summary>
            Clears the queue.
            </summary>
            <remarks>This method is not thread-safe.</remarks>
        </member>
        <member name="P:WCell.Util.Collections.LockfreeQueue`1.Count">
            <summary>
            Gets the number of elements contained in the queue.
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.Triangle.CalcNormal">
            <summary>
            Computes the normal of this triangle *without normalizing it*
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.Triangle.CalcNormalizedNormal">
            <summary>
            Computes the normalized normal of this triangle
            </summary>
        </member>
        <member name="M:WCell.Util.NLog.StreamTarget.Flush(System.TimeSpan)">
            <summary>
            Flushes any buffers.
            </summary>
            <param name="timeout">Flush timeout.</param>
        </member>
        <member name="M:WCell.Util.NLog.StreamTarget.PopulateLayouts(NLog.LayoutCollection)">
            <summary>
            Adds all layouts used by this target to the specified collection.
            </summary>
            <param name="layouts">The collection to add layouts to.</param>
        </member>
        <member name="M:WCell.Util.NLog.StreamTarget.Write(NLog.LogEventInfo)">
            <summary>
            Sends the 
            rendered logging event over the network optionally concatenating it with a newline character.
            </summary>
            <param name="logEvent">The logging event.</param>
        </member>
        <member name="P:WCell.Util.NLog.StreamTarget.Stream">
            <summary>
            The network address. Can be tcp://host:port, udp://host:port, http://host:port or https://host:port
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.Rect.Contains(WCell.Util.Graphics.Point)">
            <summary>
            Whether the rectangle contains the given Point. 
            Points laying on the rectangles border are considered to be contained.
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.Rect.Contains(System.Single,System.Single)">
            <summary>
            Whether the rectangle contains the given Point(x, y). 
            Points laying on the rectangles border are considered to be contained.
            </summary>
        </member>
        <member name="F:WCell.Util.ArrayUtil.LoadConstant">
            <summary>
            At least ensure a size of highestIndex * this, if index is not valid within an array.
            </summary>
        </member>
        <member name="M:WCell.Util.ArrayUtil.EnsureSize``1(``0[]@,System.Int32)">
            <summary>
            Ensures that the given array has at least the given size and resizes if its too small
            </summary>
        </member>
        <member name="M:WCell.Util.ArrayUtil.Get``1(``0[],System.Int32)">
            <summary>
            Returns the entry in this array at the given index, or null if the index is out of bounds
            </summary>
        </member>
        <member name="M:WCell.Util.ArrayUtil.Get``1(``0[],System.UInt32)">
            <summary>
            Returns the entry in this array at the given index, or null if the index is out of bounds
            </summary>
        </member>
        <member name="M:WCell.Util.ArrayUtil.GetMax``1(``0[],System.UInt32)">
            <summary>
            Returns arr[index] or, if index is out of bounds, arr.Last()
            </summary>
        </member>
        <member name="M:WCell.Util.ArrayUtil.Trunc``1(``0[]@)">
            <summary>
            Cuts away everything after and including the first null
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arr"></param>
        </member>
        <member name="M:WCell.Util.ArrayUtil.Prune``1(``0[]@)">
            <summary>
            Cuts away all null values
            </summary>
        </member>
        <member name="M:WCell.Util.ArrayUtil.PruneStrings(System.String[]@)">
            <summary>
            Cuts away all null values
            </summary>
        </member>
        <member name="M:WCell.Util.ArrayUtil.PruneVals``1(``0[]@)">
            <summary>
            Cuts away all null values
            </summary>
        </member>
        <member name="M:WCell.Util.ArrayUtil.Add``1(``0[]@,``0)">
            <summary>
            Adds the given value to the first slot that is not occupied in the given array
            </summary>
            <returns>The index at which it was added</returns>
        </member>
        <member name="M:WCell.Util.ArrayUtil.Concat``1(``0[]@,``0[])">
            <summary>
            Appends the given values to the end of arr
            </summary>
            <returns>The index at which it was added</returns>
        </member>
        <member name="M:WCell.Util.ArrayUtil.AddOnlyOne``1(``0[]@,``0)">
            <summary>
            Adds the given value to the first slot that is not occupied in the given array
            </summary>
            <returns>The index at which it was added</returns>
        </member>
        <member name="M:WCell.Util.ArrayUtil.AddElement``1(``0[],``0)">
            <summary>
            
            </summary>
            <returns>The index at which it was added</returns>
        </member>
        <member name="M:WCell.Util.ArrayUtil.EqualValues``1(``0[],``0[])">
            <summary>
            Believe it or not, .NET has no such method by default.
            Array.Equals is not overridden properly.
            </summary>
        </member>
        <member name="M:WCell.Util.ArrayUtil.GetWhere``1(``0[],System.Func{``0,System.Boolean})">
            <summary>
            Removes all empty entries from an array
            </summary>
        </member>
        <member name="M:WCell.Util.ArrayUtil.Fill``1(``0[],``0,System.Int32,System.Int32)">
            <summary>
            Sets all values of the given array between offset and length to the given obj
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.IContextHandler">
            <summary>
            A ContextHandlers usually represents a set of instructions to be performed by one Thread at a time and allows
            Messages to be dispatched.
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.IContextHandler.ExecuteInContext(System.Action)">
            <summary>
            Executes action instantly, if in context.
            Enqueues a Message to execute it later, if not in context.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.IContextHandler.IsInContext">
            <summary>
            Whether this ContextHandler currently belongs to the calling Thread
            </summary>
        </member>
        <member name="M:WCell.Util.Threading._ContextUtil.WaitOne(WCell.Util.Threading.IContextHandler)">
            <summary>
            Lets the given ContextHandler wait one Tick. Does nothing if within the given Handler's Context.
            </summary>
            <param name="contextHandler"></param>
        </member>
        <member name="T:WCell.Util.DynamicAccess.DontCopyAttribute">
            <summary>
            All properties with this attribute should not be copied automatically, when using PropertyAccessMgr.CopyAll
            </summary>
        </member>
        <member name="P:WCell.Util.DB.Xml.PrimaryColumn.Name">
            <summary>
            The name of the Column
            </summary>
        </member>
        <member name="P:WCell.Util.DB.Xml.PrimaryColumn.TypeName">
            <summary>
            The name of the type of the PrimaryColumn
            </summary>
        </member>
        <member name="P:WCell.Util.DB.Xml.PrimaryColumn.DefaultValueString">
            <summary>
            The name of the type of the PrimaryColumn
            </summary>
        </member>
        <member name="P:WCell.Util.DB.Xml.Column.Name">
            <summary>
            The name of the Column
            </summary>
        </member>
        <member name="P:WCell.Util.DB.Xml.Column.Table">
            <summary>
            The table to which this Column belongs (leave blank if default table)
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions">
            <summary>Extensions for TaskFactory.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.ToGeneric``1(System.Threading.Tasks.TaskFactory)">
            <summary>Creates a generic TaskFactory from a non-generic one.</summary>
            <typeparam name="TResult">Specifies the type of Task results for the Tasks created by the new TaskFactory.</typeparam>
            <param name="factory">The TaskFactory to serve as a template.</param>
            <returns>The created TaskFactory.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.ToNonGeneric``1(System.Threading.Tasks.TaskFactory{``0})">
            <summary>Creates a generic TaskFactory from a non-generic one.</summary>
            <typeparam name="TResult">Specifies the type of Task results for the Tasks created by the new TaskFactory.</typeparam>
            <param name="factory">The TaskFactory to serve as a template.</param>
            <returns>The created TaskFactory.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.GetTargetScheduler(System.Threading.Tasks.TaskFactory)">
            <summary>Gets the TaskScheduler instance that should be used to schedule tasks.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.GetTargetScheduler``1(System.Threading.Tasks.TaskFactory{``0})">
            <summary>Gets the TaskScheduler instance that should be used to schedule tasks.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.ContinuationOptionsFromCreationOptions(System.Threading.Tasks.TaskCreationOptions)">
            <summary>Converts TaskCreationOptions into TaskContinuationOptions.</summary>
            <param name="creationOptions"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.TrackedSequence(System.Threading.Tasks.TaskFactory,System.Func{System.Threading.Tasks.Task}[])">
            <summary>Asynchronously executes a sequence of tasks, maintaining a list of all tasks processed.</summary>
            <param name="factory">The TaskFactory to use to create the task.</param>
            <param name="functions">
            The functions that generate the tasks through which to iterate sequentially.
            Iteration will cease if a task faults.
            </param>
            <returns>A Task that will return the list of tracked tasks iterated.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.TrackedSequenceInternal(System.Collections.Generic.IEnumerable{System.Func{System.Threading.Tasks.Task}},System.Threading.Tasks.TaskCompletionSource{System.Collections.Generic.IList{System.Threading.Tasks.Task}})">
            <summary>Creates the enumerable to iterate through with Iterate.</summary>
            <param name="functions">
            The functions that generate the tasks through which to iterate sequentially.
            Iteration will cease if a task faults.
            </param>
            <param name="tcs">The TaskCompletionSource to resolve with the asynchronous results.</param>
            <returns>The enumerable through which to iterate.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Iterate(System.Threading.Tasks.TaskFactory,System.Collections.Generic.IEnumerable{System.Object},System.Object)">
            <summary>Asynchronously iterates through an enumerable of tasks.</summary>
            <param name="factory">The target factory.</param>
            <param name="source">The enumerable containing the tasks to be iterated through.</param>
            <param name="state">The asynchronous state for the returned Task.</param>
            <returns>A Task that represents the complete asynchronous operation.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Iterate(System.Threading.Tasks.TaskFactory,System.Collections.Generic.IEnumerable{System.Object},System.Object,System.Threading.CancellationToken)">
            <summary>Asynchronously iterates through an enumerable of tasks.</summary>
            <param name="factory">The target factory.</param>
            <param name="source">The enumerable containing the tasks to be iterated through.</param>
            <param name="state">The asynchronous state for the returned Task.</param>
            <param name="cancellationToken">The cancellation token used to cancel the iteration.</param>
            <returns>A Task that represents the complete asynchronous operation.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Iterate(System.Threading.Tasks.TaskFactory,System.Collections.Generic.IEnumerable{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>Asynchronously iterates through an enumerable of tasks.</summary>
            <param name="factory">The target factory.</param>
            <param name="source">The enumerable containing the tasks to be iterated through.</param>
            <param name="state">The asynchronous state for the returned Task.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <returns>A Task that represents the complete asynchronous operation.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Iterate(System.Threading.Tasks.TaskFactory,System.Collections.Generic.IEnumerable{System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
            <summary>Asynchronously iterates through an enumerable of tasks.</summary>
            <param name="factory">The target factory.</param>
            <param name="source">The enumerable containing the tasks to be iterated through.</param>
            <param name="state">The asynchronous state for the returned Task.</param>
            <param name="scheduler">The scheduler to which tasks will be scheduled.</param>
            <returns>A Task that represents the complete asynchronous operation.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Iterate(System.Threading.Tasks.TaskFactory,System.Collections.Generic.IEnumerable{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>Asynchronously iterates through an enumerable of tasks.</summary>
            <param name="factory">The target factory.</param>
            <param name="source">The enumerable containing the tasks to be iterated through.</param>
            <param name="state">The asynchronous state for the returned Task.</param>
            <param name="cancellationToken">The cancellation token used to cancel the iteration.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <param name="scheduler">The scheduler to which tasks will be scheduled.</param>
            <returns>A Task that represents the complete asynchronous operation.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Iterate(System.Threading.Tasks.TaskFactory,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Asynchronously iterates through an enumerable of tasks.</summary>
            <param name="factory">The target factory.</param>
            <param name="source">The enumerable containing the tasks to be iterated through.</param>
            <returns>A Task that represents the complete asynchronous operation.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Iterate(System.Threading.Tasks.TaskFactory,System.Collections.Generic.IEnumerable{System.Object},System.Threading.CancellationToken)">
            <summary>Asynchronously iterates through an enumerable of tasks.</summary>
            <param name="factory">The target factory.</param>
            <param name="source">The enumerable containing the tasks to be iterated through.</param>
            <param name="cancellationToken">The cancellation token used to cancel the iteration.</param>
            <returns>A Task that represents the complete asynchronous operation.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Iterate(System.Threading.Tasks.TaskFactory,System.Collections.Generic.IEnumerable{System.Object},System.Threading.Tasks.TaskCreationOptions)">
            <summary>Asynchronously iterates through an enumerable of tasks.</summary>
            <param name="factory">The target factory.</param>
            <param name="source">The enumerable containing the tasks to be iterated through.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <returns>A Task that represents the complete asynchronous operation.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Iterate(System.Threading.Tasks.TaskFactory,System.Collections.Generic.IEnumerable{System.Object},System.Threading.Tasks.TaskScheduler)">
            <summary>Asynchronously iterates through an enumerable of tasks.</summary>
            <param name="factory">The target factory.</param>
            <param name="source">The enumerable containing the tasks to be iterated through.</param>
            <param name="scheduler">The scheduler to which tasks will be scheduled.</param>
            <returns>A Task that represents the complete asynchronous operation.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Iterate(System.Threading.Tasks.TaskFactory,System.Collections.Generic.IEnumerable{System.Object},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>Asynchronously iterates through an enumerable of tasks.</summary>
            <param name="factory">The target factory.</param>
            <param name="source">The enumerable containing the tasks to be iterated through.</param>
            <param name="cancellationToken">The cancellation token used to cancel the iteration.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <param name="scheduler">The scheduler to which tasks will be scheduled.</param>
            <returns>A Task that represents the complete asynchronous operation.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.FromAsync(System.Threading.WaitHandle)">
            <summary>Creates a Task that will be completed when the specified WaitHandle is signaled.</summary>
            <param name="waitHandle">The WaitHandle.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.FromException(System.Threading.Tasks.TaskFactory,System.Exception)">
            <summary>Creates a Task that has completed in the Faulted state with the specified exception.</summary>
            <param name="factory">The target TaskFactory.</param>
            <param name="exception">The exception with which the Task should fault.</param>
            <returns>The completed Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.FromException``1(System.Threading.Tasks.TaskFactory,System.Exception)">
            <summary>Creates a Task that has completed in the Faulted state with the specified exception.</summary>
            <typeparam name="TResult">Specifies the type of payload for the new Task.</typeparam>
            <param name="factory">The target TaskFactory.</param>
            <param name="exception">The exception with which the Task should fault.</param>
            <returns>The completed Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.FromResult``1(System.Threading.Tasks.TaskFactory,``0)">
            <summary>Creates a Task that has completed in the RanToCompletion state with the specified result.</summary>
            <typeparam name="TResult">Specifies the type of payload for the new Task.</typeparam>
            <param name="factory">The target TaskFactory.</param>
            <param name="result">The result with which the Task should complete.</param>
            <returns>The completed Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.FromException``1(System.Threading.Tasks.TaskFactory{``0},System.Exception)">
            <summary>Creates a Task that has completed in the Faulted state with the specified exception.</summary>
            <param name="factory">The target TaskFactory.</param>
            <param name="exception">The exception with which the Task should fault.</param>
            <returns>The completed Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.FromResult``1(System.Threading.Tasks.TaskFactory{``0},``0)">
            <summary>Creates a Task that has completed in the RanToCompletion state with the specified result.</summary>
            <typeparam name="TResult">Specifies the type of payload for the new Task.</typeparam>
            <param name="factory">The target TaskFactory.</param>
            <param name="result">The result with which the Task should complete.</param>
            <returns>The completed Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed(System.Threading.Tasks.TaskFactory,System.Int32)">
            <summary>Creates a Task that will complete after the specified delay.</summary>
            <param name="factory">The TaskFactory.</param>
            <param name="millisecondsDelay">The delay after which the Task should transition to RanToCompletion.</param>
            <returns>A Task that will be completed after the specified duration.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed(System.Threading.Tasks.TaskFactory,System.Int32,System.Threading.CancellationToken)">
            <summary>Creates a Task that will complete after the specified delay.</summary>
            <param name="factory">The TaskFactory.</param>
            <param name="millisecondsDelay">The delay after which the Task should transition to RanToCompletion.</param>
            <param name="cancellationToken">The cancellation token that can be used to cancel the timed task.</param>
            <returns>A Task that will be completed after the specified duration and that's cancelable with the specified token.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed(System.Threading.Tasks.TaskFactory,System.Int32,System.Action)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="action">The delegate executed by the task.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed(System.Threading.Tasks.TaskFactory,System.Int32,System.Action,System.Threading.Tasks.TaskCreationOptions)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="action">The delegate executed by the task.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed(System.Threading.Tasks.TaskFactory,System.Int32,System.Action,System.Threading.CancellationToken)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="action">The delegate executed by the task.</param>
            <param name="cancellationToken">The cancellation token to assign to the created Task.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed(System.Threading.Tasks.TaskFactory,System.Int32,System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="action">The delegate executed by the task.</param>
            <param name="cancellationToken">The cancellation token to assign to the created Task.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <param name="scheduler">The scheduler to which the Task will be scheduled.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed(System.Threading.Tasks.TaskFactory,System.Int32,System.Action{System.Object},System.Object)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="action">The delegate executed by the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed(System.Threading.Tasks.TaskFactory,System.Int32,System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="action">The delegate executed by the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed(System.Threading.Tasks.TaskFactory,System.Int32,System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="action">The delegate executed by the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <param name="cancellationToken">The cancellation token to assign to the created Task.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed(System.Threading.Tasks.TaskFactory,System.Int32,System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="action">The delegate executed by the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <param name="cancellationToken">The cancellation token to assign to the created Task.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <param name="scheduler">The scheduler to which the Task will be scheduled.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed``1(System.Threading.Tasks.TaskFactory{``0},System.Int32,System.Func{``0})">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="function">The delegate executed by the task.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed``1(System.Threading.Tasks.TaskFactory{``0},System.Int32,System.Func{``0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="function">The delegate executed by the task.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed``1(System.Threading.Tasks.TaskFactory{``0},System.Int32,System.Func{``0},System.Threading.CancellationToken)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="function">The delegate executed by the task.</param>
            <param name="cancellationToken">The CancellationToken to assign to the Task.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed``1(System.Threading.Tasks.TaskFactory{``0},System.Int32,System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="function">The delegate executed by the task.</param>
            <param name="cancellationToken">The CancellationToken to assign to the Task.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <param name="scheduler">The scheduler to which the Task will be scheduled.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed``1(System.Threading.Tasks.TaskFactory{``0},System.Int32,System.Func{System.Object,``0},System.Object)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="function">The delegate executed by the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed``1(System.Threading.Tasks.TaskFactory{``0},System.Int32,System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="function">The delegate executed by the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <param name="cancellationToken">The CancellationToken to assign to the Task.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed``1(System.Threading.Tasks.TaskFactory{``0},System.Int32,System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="function">The delegate executed by the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.StartNewDelayed``1(System.Threading.Tasks.TaskFactory{``0},System.Int32,System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>Creates and schedules a task for execution after the specified time delay.</summary>
            <param name="factory">The factory to use to create the task.</param>
            <param name="millisecondsDelay">The delay after which the task will be scheduled.</param>
            <param name="function">The delegate executed by the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <param name="cancellationToken">The CancellationToken to assign to the Task.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <param name="scheduler">The scheduler to which the Task will be scheduled.</param>
            <returns>The created Task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Create(System.Threading.Tasks.TaskFactory,System.Action)">
            <summary>Creates a Task using the TaskFactory.</summary>
            <param name="factory">The factory to use.</param>
            <param name="action">The delegate for the task.</param>
            <returns>The created task.  The task has not been scheduled.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Create(System.Threading.Tasks.TaskFactory,System.Action,System.Threading.Tasks.TaskCreationOptions)">
            <summary>Creates a Task using the TaskFactory.</summary>
            <param name="factory">The factory to use.</param>
            <param name="action">The delegate for the task.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <returns>The created task.  The task has not been scheduled.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Create(System.Threading.Tasks.TaskFactory,System.Action{System.Object},System.Object)">
            <summary>Creates a Task using the TaskFactory.</summary>
            <param name="factory">The factory to use.</param>
            <param name="action">The delegate for the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <returns>The created task.  The task has not been scheduled.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Create(System.Threading.Tasks.TaskFactory,System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>Creates a Task using the TaskFactory.</summary>
            <param name="factory">The factory to use.</param>
            <param name="action">The delegate for the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <returns>The created task.  The task has not been scheduled.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Create``1(System.Threading.Tasks.TaskFactory,System.Func{``0})">
            <summary>Creates a Task using the TaskFactory.</summary>
            <param name="factory">The factory to use.</param>
            <param name="function">The delegate for the task.</param>
            <returns>The created task.  The task has not been scheduled.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Create``1(System.Threading.Tasks.TaskFactory,System.Func{``0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>Creates a Task using the TaskFactory.</summary>
            <param name="factory">The factory to use.</param>
            <param name="function">The delegate for the task.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <returns>The created task.  The task has not been scheduled.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Create``1(System.Threading.Tasks.TaskFactory,System.Func{System.Object,``0},System.Object)">
            <summary>Creates a Task using the TaskFactory.</summary>
            <param name="factory">The factory to use.</param>
            <param name="function">The delegate for the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <returns>The created task.  The task has not been scheduled.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Create``1(System.Threading.Tasks.TaskFactory,System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>Creates a Task using the TaskFactory.</summary>
            <param name="factory">The factory to use.</param>
            <param name="function">The delegate for the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <returns>The created task.  The task has not been scheduled.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Create``1(System.Threading.Tasks.TaskFactory{``0},System.Func{``0})">
            <summary>Creates a Task using the TaskFactory.</summary>
            <param name="factory">The factory to use.</param>
            <param name="function">The delegate for the task.</param>
            <returns>The created task.  The task has not been scheduled.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Create``1(System.Threading.Tasks.TaskFactory{``0},System.Func{``0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>Creates a Task using the TaskFactory.</summary>
            <param name="factory">The factory to use.</param>
            <param name="function">The delegate for the task.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <returns>The created task.  The task has not been scheduled.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Create``1(System.Threading.Tasks.TaskFactory{``0},System.Func{System.Object,``0},System.Object)">
            <summary>Creates a Task using the TaskFactory.</summary>
            <param name="factory">The factory to use.</param>
            <param name="function">The delegate for the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <returns>The created task.  The task has not been scheduled.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.Create``1(System.Threading.Tasks.TaskFactory{``0},System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>Creates a Task using the TaskFactory.</summary>
            <param name="factory">The factory to use.</param>
            <param name="function">The delegate for the task.</param>
            <param name="state">An object provided to the delegate.</param>
            <param name="creationOptions">Options that control the task's behavior.</param>
            <returns>The created task.  The task has not been scheduled.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.WhenAll(System.Threading.Tasks.TaskFactory,System.Threading.Tasks.Task[])">
            <summary>
            Creates a continuation Task that will compplete upon
            the completion of a set of provided Tasks.
            </summary>
            <param name="factory">The TaskFactory to use to create the continuation task.</param>
            <param name="tasks">The array of tasks from which to continue.</param>
            <returns>A task that, when completed, will return the array of completed tasks.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.WhenAll``1(System.Threading.Tasks.TaskFactory,System.Threading.Tasks.Task{``0}[])">
            <summary>
            Creates a continuation Task that will compplete upon
            the completion of a set of provided Tasks.
            </summary>
            <param name="factory">The TaskFactory to use to create the continuation task.</param>
            <param name="tasks">The array of tasks from which to continue.</param>
            <returns>A task that, when completed, will return the array of completed tasks.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.WhenAny(System.Threading.Tasks.TaskFactory,System.Threading.Tasks.Task[])">
            <summary>
            Creates a continuation Task that will complete upon
            the completion of any one of a set of provided Tasks.
            </summary>
            <param name="factory">The TaskFactory to use to create the continuation task.</param>
            <param name="tasks">The array of tasks from which to continue.</param>
            <returns>A task that, when completed, will return the completed task.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.TaskFactoryExtensions.WhenAny``1(System.Threading.Tasks.TaskFactory,System.Threading.Tasks.Task{``0}[])">
            <summary>
            Creates a continuation Task that will complete upon
            the completion of any one of a set of provided Tasks.
            </summary>
            <param name="factory">The TaskFactory to use to create the continuation task.</param>
            <param name="tasks">The array of tasks from which to continue.</param>
            <returns>A task that, when completed, will return the completed task.</returns>
        </member>
        <member name="T:WCell.Util.ObjectPools.ObjectPoolInfo">
            <summary>
            A structure that contains information about an object pool.
            </summary>
        </member>
        <member name="F:WCell.Util.ObjectPools.ObjectPoolInfo.HardReferences">
            <summary>
            The number of hard references contained in the pool.
            </summary>
        </member>
        <member name="F:WCell.Util.ObjectPools.ObjectPoolInfo.WeakReferences">
            <summary>
            The number of weak references contained in the pool.
            </summary>
        </member>
        <member name="M:WCell.Util.ObjectPools.ObjectPoolInfo.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="weak">The number of weak references in the pool.</param>
            <param name="hard">The number of hard references in the pool.</param>
        </member>
        <member name="T:WCell.Util.ObjectPools.ObjectPool`1">
            <summary>
            This class represents a pool of objects.
            </summary>
        </member>
        <member name="T:WCell.Util.ObjectPools.IObjectPool">
            <summary>
            Interface for an object pool.
            </summary>
            <remarks>
            An object pool holds reusable objects. See zzObjectPoolMgr for more details.
            </remarks>
        </member>
        <member name="M:WCell.Util.ObjectPools.IObjectPool.Recycle(System.Object)">
            <summary>
            Enqueues an object in the pool to be reused.
            </summary>
            <param name="obj">The object to be put back in the pool.</param>
        </member>
        <member name="M:WCell.Util.ObjectPools.IObjectPool.ObtainObj">
            <summary>
            Grabs an object from the pool.
            </summary>
            <returns>An object from the pool.</returns>
        </member>
        <member name="P:WCell.Util.ObjectPools.IObjectPool.AvailableCount">
            <summary>
            Amount of available objects in pool
            </summary>
        </member>
        <member name="P:WCell.Util.ObjectPools.IObjectPool.ObtainedCount">
            <summary>
            Amount of objects that have been obtained but not recycled.
            </summary>
        </member>
        <member name="F:WCell.Util.ObjectPools.ObjectPool`1._queue">
            <summary>
            A queue of objects in the pool.
            </summary>
        </member>
        <member name="F:WCell.Util.ObjectPools.ObjectPool`1._minSize">
            <summary>
            The minimum # of hard references that must be in the pool.
            </summary>
        </member>
        <member name="F:WCell.Util.ObjectPools.ObjectPool`1._hardReferences">
            <summary>
            The number of hard references in the queue.
            </summary>
        </member>
        <member name="F:WCell.Util.ObjectPools.ObjectPool`1._obtainedReferenceCount">
            <summary>
            The number of hard references in the queue.
            </summary>
        </member>
        <member name="F:WCell.Util.ObjectPools.ObjectPool`1._createObj">
            <summary>
            Function pointer to the allocation function.
            </summary>
        </member>
        <member name="M:WCell.Util.ObjectPools.ObjectPool`1.#ctor(System.Func{`0})">
            <summary>
            Constructor
            </summary>
            <param name="func">Function pointer to the allocation function.</param>
        </member>
        <member name="M:WCell.Util.ObjectPools.ObjectPool`1.#ctor(System.Func{`0},System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="func">Function pointer to the allocation function.</param>
        </member>
        <member name="M:WCell.Util.ObjectPools.ObjectPool`1.Recycle(`0)">
            <summary>
            Adds an object to the queue.
            </summary>
            <param name="obj">The object to be added.</param>
            <remarks>If there are at least <see cref="P:WCell.Util.ObjectPools.ObjectPool`1.MinimumSize"/> hard references in the pool then the object is added as a WeakReference.
            A WeakReference allows an object to be collected by the GC if there are no other hard references to it.</remarks>
        </member>
        <member name="M:WCell.Util.ObjectPools.ObjectPool`1.Recycle(System.Object)">
            <summary>
            Adds an object to the queue.
            </summary>
            <param name="obj">The object to be added.</param>
            <remarks>If there are at least <see cref="P:WCell.Util.ObjectPools.ObjectPool`1.MinimumSize"/> hard references in the pool then the object is added as a WeakReference.
            A WeakReference allows an object to be collected by the GC if there are no other hard references to it.</remarks>
        </member>
        <member name="M:WCell.Util.ObjectPools.ObjectPool`1.Obtain">
            <summary>
            Removes an object from the queue.
            </summary>
            <returns>An object from the queue or a new object if none were in the queue.</returns>
        </member>
        <member name="M:WCell.Util.ObjectPools.ObjectPool`1.ObtainObj">
            <summary>
            Removes an object from the queue.
            </summary>
            <returns>An object from the queue or a new object if none were in the queue.</returns>
        </member>
        <member name="P:WCell.Util.ObjectPools.ObjectPool`1.HardReferenceCount">
            <summary>
            Gets the number of hard references that are currently in the pool.
            </summary>
        </member>
        <member name="P:WCell.Util.ObjectPools.ObjectPool`1.MinimumSize">
            <summary>
            Gets the minimum size of the pool.
            </summary>
        </member>
        <member name="P:WCell.Util.ObjectPools.ObjectPool`1.Info">
            <summary>
            Gets information about the object pool.
            </summary>
            <value>A new <see cref="T:WCell.Util.ObjectPools.ObjectPoolInfo"/> object that contains information about the pool.</value>
        </member>
        <member name="T:WCell.Util.WeakReference`1">
            <summary>
            Represents a weak reference, which references an object while still allowing   
            that object to be reclaimed by garbage collection.    
            </summary>    
            <seealso href="http://ondevelopment.blogspot.com/2008/01/generic-weak-reference.html"/>
            <typeparam name="T">The type of the object that is referenced.</typeparam>    
        </member>
        <member name="M:WCell.Util.WeakReference`1.#ctor(`0)">
            <summary>        
            Initializes a new instance of the Minimal.WeakReference{T} class, referencing        
            the specified object.        
            </summary>        
            <param name="target">The object to reference.</param>        
        </member>
        <member name="M:WCell.Util.WeakReference`1.#ctor(`0,System.Boolean)">
            <summary>        
            Initializes a new instance of the WeakReference{T} class, referencing 
            the specified object and using the specified resurrection tracking. 
            </summary>        
            <param name="target">An object to track.</param> 
            <param name="trackResurrection">Indicates when to stop tracking the object. If true, the object is tracked 
            after finalization; if false, the object is only tracked until finalization.</param> 
        </member>
        <member name="M:WCell.Util.WeakReference`1.op_Implicit(`0)~WCell.Util.WeakReference{`0}">
            <summary> 
            Casts an object of the type T to a weak reference 
            of T. 
            </summary> 
        </member>
        <member name="M:WCell.Util.WeakReference`1.op_Implicit(WCell.Util.WeakReference{`0})~`0">
            <summary> 
            Casts a weak reference to an object of the type the 
            reference represents. 
            </summary> 
        </member>
        <member name="P:WCell.Util.WeakReference`1.Target">
            <summary> 
            Gets or sets the object (the target) referenced by the current WeakReference{T} 
            object. 
            </summary> 
        </member>
        <member name="T:WCell.Util.StringUtils">
            <summary>
            </summary>
        </member>
        <member name="M:WCell.Util.StringUtils.ToDelimitedString(System.String[],System.String)">
            <summary>
            Combines the strings of a string array into one delimited string
            </summary>
            <param name="inputArray">The string array to combine</param>
            <param name="delimiter">The delimited</param>
            <returns>A string of the delimited strings</returns>
        </member>
        <member name="M:WCell.Util.StringUtils.ToDelimitedString(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Combines the strings of an List&lt;string&gt; into one delimited string
            </summary>
            <param name="inputArray">The List&lt;string&gt; to combine</param>
            <param name="delimiter">The delimited</param>
            <returns>A string of the delimited strings</returns>
        </member>
        <member name="M:WCell.Util.StringUtils.GetReadableList(System.String[])">
            <summary>
            Combines the strings of a string array into a string, which resembles a list
            </summary>
            <param name="szArray">The string array to combine</param>
            <returns>A string which resembles a list, using commas, and follows the rules of English grammar</returns>
        </member>
        <member name="M:WCell.Util.StringUtils.Split(System.String,System.Char)">
            <summary>
            Safely splits a string without erroring if the delimiter is not present
            </summary>
            <param name="inputSz">The string to split</param>
            <param name="delimiter">The character to split on</param>
            <returns>A string array of the split string</returns>
        </member>
        <member name="M:WCell.Util.StringUtils.ToReadableIPAddress(System.Byte[])">
            <summary>
            Converts a byte array to a period-delimited string
            </summary>
            <param name="inputArray">the byte array to convert</param>
            <returns>a period-delimited string of the converted byte array</returns>
        </member>
        <member name="M:WCell.Util.StringUtils.ToCapitalizedString(System.String)">
            <summary>
            Converts a random string (aBcDeFG) to a capitalized string (Abcdefg)
            </summary>
        </member>
        <member name="M:WCell.Util.StringUtils.ToFriendlyName(System.String)">
            <summary>
            Capitalizes the string and also considers (and removes) special characters, such as "_"
            </summary>
        </member>
        <member name="T:WCell.Util.ReflectionUtils">
            <summary>
            Reflection utilities used in the network layer
            </summary>
        </member>
        <member name="M:WCell.Util.ReflectionUtils.SatisfiesGenericConstraints(System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Checks if a method's parameters match a given array of types
            </summary>
            <param name="generic_method_definition">the method to check</param>
            <param name="types">the types to check for</param>
            <returns>true if the method has the required types for its parameters</returns>
        </member>
        <member name="M:WCell.Util.ReflectionUtils.CanCreateDelegate``1(System.Reflection.MethodInfo)">
            <summary>
            Checks if a delegate can be made from this given method for the given delegate type
            </summary>
            <typeparam name="DelegateType">the type of delegate to be created</typeparam>
            <param name="method">the method to be transformed into a delegate</param>
            <returns>true if the given method will be able to be of the given delegate type; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.CollectionExtensions.Iterate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            The predicate returns false to stop the iteration (and to indicate that it found the item).
            Iterate returns true once the predicate returned false the first time.
            </summary>
        </member>
        <member name="M:WCell.Util.CollectionExtensions.MakeArray``1(System.Collections.Generic.HashSet{``0})">
            <summary>
            For unexplainable reasons, HashSet's ToArray method is internal
            </summary>
        </member>
        <member name="M:WCell.Util.CollectionExtensions.NotNull``1(System.Collections.Generic.List{``0})">
            <summary>
            Returns either the list or a new List if list is null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.CollectionExtensions.IsSimpleType(System.Type)">
            <summary>
            Simple types are primitive-types and strings
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:WCell.Util.Graphics.BoundingBox">
            <summary>
            Defines an axis-aligned bounding box.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.BoundingBox.Min">
            <summary>
            The lower-left bound of the box.
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.BoundingBox.Max">
            <summary>
            The upper-right bound of the box.
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingBox.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.BoundingBox"/> with the given coordinates.
            </summary>
            <param name="minX">lower-bound X</param>
            <param name="minY">lower-bound Y</param>
            <param name="minZ">lower-bound Z</param>
            <param name="maxX">upper-bound X</param>
            <param name="maxY">upper-bound Y</param>
            <param name="maxZ">upper-bound Z</param>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingBox.#ctor(System.Single,System.Single,System.Single,WCell.Util.Graphics.Vector3)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.BoundingBox"/> with the given coordinates.
            </summary>
            <param name="minX">lower-bound X</param>
            <param name="minY">lower-bound Y</param>
            <param name="minZ">lower-bound Z</param>
            <param name="max">upper-bound vector</param>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingBox.#ctor(WCell.Util.Graphics.Vector3,System.Single,System.Single,System.Single)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.BoundingBox"/> with the given coordinates.
            </summary>
            <param name="min">lower-bound vector</param>
            <param name="maxX">upper-bound X</param>
            <param name="maxY">upper-bound Y</param>
            <param name="maxZ">upper-bound Z</param>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingBox.#ctor(WCell.Util.Graphics.Vector3,WCell.Util.Graphics.Vector3)">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.BoundingBox"/> with the given coordinates.
            </summary>
            <param name="min">lower-bound vector</param>
            <param name="max">upper-bound vector</param>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingBox.#ctor(WCell.Util.Graphics.Vector3[])">
            <summary>
            Creates a new <see cref="T:WCell.Util.Graphics.BoundingBox"/> containing the given vectors.
            </summary>
            <param name="vectors">The array of vectors to use.</param>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingBox.Intersects(WCell.Util.Graphics.BoundingBox@)">
            <summary>
            Checks whether the current <see cref="T:WCell.Util.Graphics.BoundingBox"/> intersects with the given <see cref="T:WCell.Util.Graphics.BoundingBox"/>.
            </summary>
            <param name="box">the <see cref="T:WCell.Util.Graphics.BoundingBox"/> to check for intersection</param>
            <returns>an enumeration value describing the type of intersection between the two boxes</returns>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingBox.Intersects(WCell.Util.Graphics.BoundingSphere@)">
            <summary>
            Checks whether the current <see cref="T:WCell.Util.Graphics.BoundingBox"/> intersects with the given <see cref="T:WCell.Util.Graphics.BoundingSphere"/>.
            </summary>
            <param name="sphere">the <see cref="T:WCell.Util.Graphics.BoundingSphere"/> to check for intersection</param>
            <returns>an enumeration value describing the type of intersection between the box and sphere</returns>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingBox.Contains(WCell.Util.Graphics.BoundingBox@)">
            <summary>
            Checks whether the <see cref="T:WCell.Util.Graphics.BoundingBox"/> contains the given <see cref="T:WCell.Util.Graphics.BoundingBox"/>.
            </summary>
            <param name="box">the <see cref="T:WCell.Util.Graphics.BoundingBox"/> to check for containment.</param>
            <returns>true if the <see cref="T:WCell.Util.Graphics.BoundingBox"/> is contained; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingBox.Contains(WCell.Util.Graphics.Vector3@)">
            <summary>
            Checks whether the <see cref="T:WCell.Util.Graphics.BoundingBox"/> contains the given point.
            </summary>
            <param name="point">the point to check for containment.</param>
            <returns>true if the point is contained; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingBox.Contains(WCell.Util.Graphics.Vector4@)">
            <summary>
            Checks whether the <see cref="T:WCell.Util.Graphics.BoundingBox"/> contains the given point.
            </summary>
            <param name="point">the point to check for containment.</param>
            <returns>true if the point is contained; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingBox.Equals(WCell.Util.Graphics.BoundingBox)">
            <summary>
            Checks equality of two boxes.
            </summary>
            <param name="other">the other box to compare with</param>
            <returns>true if both boxes are equal; false otherwise</returns>
        </member>
        <member name="M:WCell.Util.Graphics.BoundingBox.Equals(System.Object)">
            <summary>
            Checks equality with another object.
            </summary>
            <param name="obj">the object to compare</param>
            <returns>true if the object is <see cref="T:WCell.Util.Graphics.BoundingBox"/> and is equal; false otherwise</returns>
        </member>
        <member name="P:WCell.Util.DB.Xml.XmlWhereClause.EqualColumn">
            <summary>
            The column of the table that this WhereStatement belongs to and should be compared
            to Column2 of Table2.
            </summary>
        </member>
        <member name="T:WCell.Util.DB.SimpleDataColumn">
            <summary>
            Maps a table-column to a DataField
            </summary>
        </member>
        <member name="P:WCell.Util.DB.SimpleDataColumn.Index">
            <summary>
            The index of this column within the query-result
            </summary>
        </member>
        <member name="P:WCell.Util.DB.SimpleDataColumn.IsEmpty">
            <summary>
            An empty DataColumn has no reader and thus is not necessarily mapped.
            </summary>
        </member>
        <member name="T:WCell.Util.DB.LightDBMgr">
            <summary>
            Static container and utility class for Table- and DataHolder-mappings
            </summary>
        </member>
        <member name="T:WCell.Util.Commands.CommandMgr`1">
            <summary>
            Command provider class
            </summary>
        </member>
        <member name="F:WCell.Util.Commands.CommandMgr`1.TriggerValidator">
            <summary>
            Validates whether a the given command may be triggered (checks for privileges etc)
            </summary>
        </member>
        <member name="F:WCell.Util.Commands.CommandMgr`1.allCommandsByType">
            <summary>
            Includes Subcommands
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.Execute(WCell.Util.Commands.CmdTrigger{`0})">
            <summary>
            Executes a specific Command with parameters.
            
            Interprets the first word as alias, takes all enabled Commands with the specific alias out of the 
            CommandsByAlias-map and triggers the specific Process() method on all of them.
            If the processing of the command raises an Exception, the fail events are triggered.
            </summary>
            <returns>True if at least one Command was triggered, otherwise false.</returns>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.EvalNext(WCell.Util.Commands.CmdTrigger{`0},System.Object)">
            <summary>
            Call Eval on specified command
            </summary>
            <param name="trigger"></param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.Execute(WCell.Util.Commands.CmdTrigger{`0},WCell.Util.Commands.BaseCommand{`0},System.Boolean)">
            <summary>
            Lets the given CmdTrigger trigger the given Command.
            </summary>
            <param name="trigger"></param>
            <param name="cmd"></param>
            <param name="silentFail">Will not reply if it failed due to target restrictions or privileges etc</param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.Eval(WCell.Util.Commands.CmdTrigger{`0},WCell.Util.Commands.BaseCommand{`0})">
            <summary>
            Lets the given CmdTrigger trigger the given Command.
            </summary>
            <param name="trigger"></param>
            <param name="cmd"></param>
            <param name="silentFail">Will not reply if it failed due to target restrictions or privileges etc</param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.Eval(WCell.Util.Commands.CmdTrigger{`0},WCell.Util.Commands.BaseCommand{`0},System.Boolean)">
            <summary>
            Lets the given CmdTrigger trigger the given Command.
            </summary>
            <param name="trigger"></param>
            <param name="cmd"></param>
            <param name="silentFail">Will not reply if it failed due to target restrictions or privileges etc</param>
            <returns></returns>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.Add(WCell.Util.Commands.Command{`0})">
            <summary>
            Adds a Command to the CommandsByAlias.
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.Add(System.Type)">
            <summary>
            Adds a Command-instance of the specific type, if it is a Command-type
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.AddCmdsOfAsm(System.Reflection.Assembly)">
            <summary>
            Finds and adds all Commands of the given Assembly
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.Remove(WCell.Util.Commands.Command{`0})">
            <summary>
            Removes a Command.
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.Get(System.String)">
            <summary>
            Returns all Commands with the given Alias
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.AddDefaultCallCommand(WCell.Util.Toolshed.ToolMgr)">
            <summary>
            Removes all Commands of the specific Type from the CommandsByAlias.
            </summary>
            <returns>True if any commands have been removed, otherwise false.</returns>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.TriggerHelp(WCell.Util.Commands.CmdTrigger{`0})">
            <summary>
            Gives help
            TODO: Localization
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.TriggerHelp(WCell.Util.Commands.CmdTrigger{`0},System.Boolean)">
            <summary>
            Gives help
            TODO: Localization
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.ExecFile(System.String,WCell.Util.Commands.CmdTrigger{`0})">
            <summary>
            
            </summary>
            <param name="filename"></param>
            <param name="trigger"></param>
        </member>
        <member name="M:WCell.Util.Commands.CommandMgr`1.ExecFile(System.String,WCell.Util.Commands.CmdTrigger{`0},System.Func{WCell.Util.Commands.CmdTrigger{`0},System.Int32,System.Boolean})">
            <summary>
            
            </summary>
            <param name="filename"></param>
            <param name="trigger"></param>
            <param name="cmdValidator">Validates whether the given trigger may execute. Second parameter is line no.</param>
        </member>
        <member name="E:WCell.Util.Commands.CommandMgr`1.UnknownCommand">
            <summary>
            Is triggered whenever an unknown command has been used
            </summary>
        </member>
        <member name="P:WCell.Util.Commands.CommandMgr`1.Item(System.String)">
            <summary>
            Returns the Command with the given Name.
            </summary>
        </member>
        <member name="P:WCell.Util.Commands.CommandMgr`1.CommandsByAlias">
            <summary>
            The Table of all Commands which exists for the use of the ReactTo() method
            (Filled by the Initialize() method).
            The keys are all possible aliases of all commands and the values are ArrayLists of Commands 
            which are associated with the specific alias.
            The aliases are stored case-insensitively. 
            Use the Remove(Command) and Add(Command) methods to manipulate this CommandsByAlias.
            </summary>
        </member>
        <member name="T:WCell.Util.Commands.CommandMgr`1.TriggerValidationHandler">
            <summary>
            Validates whether a command may be triggered.
            </summary>
            <param name="trigger"></param>
            <param name="cmd"></param>
            <param name="silent">Whether there should be no output during this check</param>
            <returns>Whether the given command may be triggered by the given trigger</returns>
        </member>
        <member name="T:WCell.Util.Commands.CommandMgr`1.ConsoleCmdTrigger">
            <summary>
            Default trigger for Console-interaction
            </summary>
        </member>
        <member name="T:WCell.Util.Commands.Command`1">
            <summary>
            Basic Command Class, Inherit your Commands from here. Automatically creates one instance
            per IrcClient when the Class is loaded, using the default constructor.
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.Command`1.#ctor">
            <summary>
            In the Constructor you deliver the alias names. Calling this ctor automatically sets
            the Instance to the newly invoked instance.
            </summary>
        </member>
        <member name="M:WCell.Util.Commands.Command`1.MayTrigger(WCell.Util.Commands.CmdTrigger{`0},WCell.Util.Commands.BaseCommand{`0},System.Boolean)">
            <summary>
            Determines whether the given command may ever be used in this Context, depending
            on the trigger's parameters that the triggerer cannot currently change and 
            are not already checked globally by the TriggerValidator.
            </summary>
        </member>
        <member name="T:WCell.Util.Commands.CommandMgr`1.HelpCommand">
            <summary>
            TODO: Use localized strings
            The help command is special since it generates output.
            This output needs to be shown in the GUI if used from commandline and 
            sent to the requester if executed remotely.
            </summary>
        </member>
        <member name="T:WCell.Util.Commands.CommandMgr`1.ExecFileCommand">
            <summary>
            The help command is special since it generates output.
            This output needs to be shown in the GUI if used from commandline and 
            sent to the requester if executed remotely.
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.LinqToTasks">
            <summary>
            Provides LINQ support for Tasks by implementing the primary standard query operators.
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.LinqToTasks.OneElementGrouping`2">
            <summary>Represents a grouping of one element.</summary>
            <typeparam name="TKey">The type of the key for the element.</typeparam>
            <typeparam name="TElement">The type of the element.</typeparam>
        </member>
        <member name="T:WCell.Util.EmailAddressParser">
             <summary>
             Edited by Domi for some performance gain
             
             Implements an email validation utility class
             Validation based on code from
             http://www.aspemporium.com/aspEmporium/tutorials/emailvalidation.asp
             We added checks for length as defined at
             http://email.about.com/od/emailbehindthescenes/f/address_length.htm
             Validates an email address for proper syntax.
             </summary>
             <example>
             Validate an array of email addresses with the 
             <see cref="T:WCell.Util.EmailAddressParser"/> class.
             <code>
             string[]             emails;
             EmailSyntaxValidator emailsyntaxvalidator;
             int                  countgood=0, countbad=0;
             
            
             //TODO: set emails string[] array
            
            
             //validate each email in the array
             foreach(string email in emails)
             {
             	emailsyntaxvalidator = new EmailSyntaxValidator(email, true);
             	if (emailsyntaxvalidator.IsValid)
             	{
             		countgood ++;
             	}
             	else
             	{
             		Console.WriteLine(email);
             		countbad ++;
             	}
             	emailsyntaxvalidator = null;
             }
            
            
             Console.WriteLine("good: {0}\r\nbad : {1}", countgood, countbad);
             </code>
             </example>
             <remarks>
             <para>
             Validates emails for proper syntax as detailed here:
             </para>
             <para>
             <A HREF="http://www.aspemporium.com/aspEmporium/tutorials/emailvalidation.asp">Email Validation - Explained</A>
             </para>
             <para> </para>
             <para>
             Version Information
             </para>
             <para>
             	    Email verification in general has had a checkered history at the ASP 
             	    Emporium. It took a while but I think we finally came up with something 
             	    good... Here's the short version history of all email validation 
             	    software from ASP Emporium...
             </para>
             <para>
             All future versions of email validation from ASPEmporium will be C# classes
             written for the .NET framework.
             </para>
             <para>
             		10/2002 v4.0 (C#)
             <list type="bullet">
             	<item>
             		<description>
             			Added new TLD (.int). Thanks to alex.wernhardt@web.de
             		</description>
             	</item>
             	<item>
             		<description>
             			Rebuilt from the ground up as a C# class that uses
             			only regular expressions for string parsing.
             		</description>
             	</item>
             	<item>
             		<description>
             			Supports all the rules as detailed here:
             			<A HREF="http://www.aspemporium.com/aspEmporium/tutorials/emailvalidation.asp">Email Validation - Explained</A>
             			This repairs all known issues in version 3.2 which
             			was written in JScript for classic ASP.
             		</description>
             	</item>
             </list>
             </para>
             <para>
             		10/2002 v4.0 (JScript)
             <list type="bullet">
             	<item>
             		<description>
             			Added new TLD (.int). Thanks to alex.wernhardt@web.de
             		</description>
             	</item>
             	<item>
             		<description>
             			Supports all the rules as detailed here:
             			<A HREF="http://www.aspemporium.com/aspEmporium/tutorials/emailvalidation.asp">Email Validation - Explained</A>
             			This repairs all known issues in version 3.2 which
             			was written in JScript for classic ASP.
             		</description>
             	</item>
             	<item>
             		<description>
             			This is the last edition of email software that is
             			written for classic ASP (JScript/VBScript).
             		</description>
             	</item>
             </list>
             </para>
             <para>
             		2/2002 v3.2 (JScript)
             <list type="bullet">
             	<item>
             		<description>
             			fixed a problem that allows emails like test@mydomain.......com
             			  to pass through. Thanks to g.falcone@mclink.it for letting
             			  me know about it.
             		</description>
             	</item>
             </list>
             </para>
             <para>
             		11/2001 v3.1 (JScript)
             <list type="bullet">
             	<item>
             		<description>
             			added new tlds. thanks to alex.wernhardt@web.de for sending
             			  me the list - http://www.icann.org/tlds/
             		</description>
             	</item>
             	<item>
             		<description>
             			new tlds: aero, biz, coop, info, museum, name, pro
             		</description>
             	</item>
             </list>
             </para>
             <para>
             		9/2001  v3.0 (JScript)
             <list type="bullet">
             	<item>
             		<description>
             			fixed spaced email problem. thanks to mikael@perfoatris.com 
             			  for the report.
             		</description>
             	</item>
             	<item>
             		<description>
             			put the length check right in the function rather
             			  than relying on a programmer to check length before
             			  testing an email. thanks to eduardo.azambuja@uol.com.br for
             			  bringing that to my attention.
             		</description>
             	</item>
             </list>
             </para>
             <para>
             		7/2001  v2.5 (JScript)
             <list type="bullet">
             	<item>
             		<description>
             			forgot the TLD (.gov). added now...
             		</description>
             	</item>
             	<item>
             		<description>
             			fixed @@ problem... thanks to davidchersg@yahoo.com for
             			  letting me know that the problem was still there.
             		</description>
             	</item>
             </list>
             </para>
             <para>
             		5/2001  v2.0 (JScript)
             <list type="bullet">
             	<item>
             		<description>
             			added verification of all known TLDs as of
             			  May 2001: http://www.behindtheurl.com/TLD/
             		</description>
             	</item>
             	<item>
             		<description>
             			added line to remove leading and trailing spaces before
             			  testing email
             			    http://www.aspemporium.com/aspEmporium/feedback/feedbacklib.asp?mail=200105060001
             		</description>
             	</item>
             	<item>
             		<description>
             			regular expression improvements by:
             				Bj�rn Hansson  -  http://nytek.nu
             			  you can view his emails here:
             			    http://www.aspemporium.com/aspEmporium/feedback/feedbacklib.asp?mail=200104180005
             			    http://www.aspemporium.com/aspEmporium/feedback/feedbacklib.asp?mail=200104090006
             			    http://www.aspemporium.com/aspEmporium/feedback/feedbacklib.asp?mail=200104090005
             		</description>
             	</item>
             	<item>
             		<description>
             			this email verification software replaces all other email 
             			  verification software at the ASP Emporium. VBScript versions 
             			  have been abandoned in favor of this JScript version.
             		</description>
             	</item>
             </list>
             </para>
             <para>
             		2/2001  v1.5 (JScript)
             <list type="bullet">
             	<item>
             		<description>
             			Regular Expression introduced to validate emails. Basically 
             			  a re-hashed version of the VBScript edition of IsEmail, aka 
             			  the EmailVerification object 3.0 (next line below)
             		</description>
             	</item>
             </list>
             </para>
             <para>
             		12/2000 v3.0 (VBScript)
             <list type="bullet">
             	<item>
             		<description>
             			EmailVerification Class released, resolving multiple domain 
             			  and user name problems.
             		</description>
             	</item>
             	<item>
             		<description>
             			Abandoned VBScript processing of emails in favor of regular 
             			  expressions.
             		</description>
             	</item>
             	<item>
             		<description>
             			New VBScript class structure.
             		</description>
             	</item>
             </list>
             </para>
             <para>
             		8/2000  v1.0 (JScript)
             <list type="bullet">
             	<item>
             		<description>
             			Initial Release of IsEmail for JScript is a lame function 
             			  that uses weak JScript inherent functions like indexOf... 
             			  This is essentually a copy of the vbscript edition of the
             			  software, version 2, remembered on the next line below...
             		</description>
             	</item>
             </list>
             </para>
             <para>
             		8/2000  v2.0 (VBScript)
             <list type="bullet">
             	<item>
             		<description>
             			IsEmail function updated to resolve several issues but 
             			  multiple domains still pose a problem.
             		</description>
             	</item>
             </list>
             </para>
             <para>
             		4/2000  v1.0 (VBScript)
             <list type="bullet">
             	<item>
             		<description>
             			IsEmail function introduced
             			  (used in the Simple Email Verification example)
             		</description>
             	</item>
             </list>
             </para>
             <para>
             		4/2000  v0.1 (VBScript)
             <list type="bullet">
             	<item>
             		<description>
             			First email validation code at the ASP Emporium checks only 
             			  for an @ and a . (Used in the first version of the 
             			  autoresponder example)
             		</description>
             	</item>
             </list>
             </para>
             </remarks>
        </member>
        <member name="M:WCell.Util.EmailAddressParser.Valid(System.String,System.Boolean)">
            <summary>
            Determines if an email has valid syntax
            </summary>
            <param name="email">the email to test</param>
            <param name="TLDrequired">indicates whether or not the 
            email must end with a known TLD to be considered valid</param>
            <returns>boolean indicating if the email has valid syntax</returns>
            <remarks>
            Validates an email address specifying whether or not
            the email is required to have a TLD that is valid.
            </remarks>
        </member>
        <member name="M:WCell.Util.EmailAddressParser.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the EmailSyntaxValidator
            </summary>
            <param name="email">the email to test</param>
            <param name="TLDrequired">indicates whether or not the 
            email must end with a known TLD to be considered valid</param>
            <remarks>
            The initializer creates an instance of the EmailSyntaxValidator
            class to validate a single email. You can specify whether or not
            the TLD is required and should be validated.
            </remarks>
        </member>
        <member name="M:WCell.Util.EmailAddressParser.ParseAddress(System.String)">
            <summary>
            separates email account from domain
            </summary>
            <param name="email">the email to parse</param>
            <returns>boolean indicating success of separation</returns>
        </member>
        <member name="M:WCell.Util.EmailAddressParser.RemoveBrackets(System.String)">
            <summary>
            removes outer brackets from an email address
            </summary>
            <param name="input">the email to parse</param>
            <returns>the email without brackets</returns>
        </member>
        <member name="M:WCell.Util.EmailAddressParser.Trim(System.String)">
            <summary>
            trims any leading and trailing white space from the email
            </summary>
            <param name="input">the email to parse</param>
            <returns>the email with no leading or trailing white space</returns>
        </member>
        <member name="P:WCell.Util.EmailAddressParser.IsValid">
            <summary>
            Gets a value indicating whether or not the email address 
            has valid syntax
            </summary>
            <remarks>
            This property returns a boolean indicating whether or not
            the email address has valid syntax as determined by the
            class.
            </remarks>
            <value>boolean indicating the validity of the email</value>
        </member>
        <member name="P:WCell.Util.EmailAddressParser.Domain">
            <summary>
            Get the domain part of the email address.
            </summary>
            <remarks>
            This property returns the domain part of the email
            address if and only if the email is considered valid
            by the class. Otherwise null is returned.
            </remarks>
            <value>string representing the domain of the email</value>
        </member>
        <member name="P:WCell.Util.EmailAddressParser.Account">
            <summary>
            Get the account part of the email address.
            </summary>
            <remarks>
            This property returns the account part of the email
            address if and only if the email is considered valid
            by the class. Otherwise null is returned.
            </remarks>
            <value>string representing the account of the email</value>
        </member>
        <member name="P:WCell.Util.EmailAddressParser.Address">
            <summary>
            Gets the email address as entered.
            </summary>
            <remarks>
            This property is filled regardless of the validity of the email.
            It contains the email as it was entered into the class.
            </remarks>
            <value>string representing the email address as entered</value>
        </member>
        <member name="P:WCell.Util.DB.Xml.NestedSimpleFieldDefinition.Fields">
            <summary>
            The fields of the type the DataField has
            </summary>
        </member>
        <member name="F:WCell.Util.Data.PersistentAttribute.AccessorType">
            <summary>
            A custom variable accessor.
            </summary>
        </member>
        <member name="F:WCell.Util.Data.PersistentAttribute.ReadType">
            <summary>
            Used to read data from the db as this type
            </summary>
        </member>
        <member name="F:WCell.Util.Data.PersistentAttribute.ActualType">
            <summary>
            Used if this object is actually of a different type then it's field/property declares
            </summary>
        </member>
        <member name="M:WCell.Util.Data.PersistentAttribute.#ctor(System.Type)">
            <summary>
            Used to convert the type in the Db to this type
            </summary>
        </member>
        <member name="P:WCell.Util.Data.DataHolderAttribute.DependsOnField">
            <summary>
            The field that delivers the values to decide the depending Producer
            </summary>
        </member>
        <member name="F:WCell.Util.Variables.TypeVariableDefinition.Object">
            <summary>
            The object that holds the field or property (or null if static)
            </summary>
        </member>
        <member name="M:WCell.Util.Variables.TypeVariableDefinition.GetSafeName">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:WCell.Util.Toolshed.NoToolAttribute">
            <summary>
            Marks a method to be excluded from the Tool-search.
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.IMessage">
            <summary>
            Defines the interface of a message.
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.IMessage.Execute">
            <summary>
            Executes the message.
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.Message">
            <summary>
            Defines a message with no input parameters.
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.Message.Obtain(System.Action)">
            <summary>
            Returns a recycled or new Message object with the given callback.
            TODO: Object recycling
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.Message.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.Message.#ctor(System.Action)">
            <summary>
            Constructs a message with the specific callback.
            </summary>
            <param name="callback">the callback to invoke when the message is executed</param>
        </member>
        <member name="M:WCell.Util.Threading.Message.Execute">
            <summary>
            Executes the message, calling any callbacks that are bound.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message.Callback">
            <summary>
            The callback that is called when the message is executed.
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.WaitMessage">
            <summary>
            Rather performance-hungry message to ensure that a task
            executed before continuing
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.WaitMessage.Wait">
            <summary>
            Waits until this Message executed.
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.Message1`1">
            <summary>
            Defines a message with one input parameter.
            </summary>
            <typeparam name="T1">the type of the first input parameter</typeparam>
        </member>
        <member name="M:WCell.Util.Threading.Message1`1.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.Message1`1.#ctor(System.Action{`0})">
            <summary>
            Constructs a message with the specific callback.
            </summary>
            <param name="callback">the callback to invoke when the message is executed</param>
        </member>
        <member name="M:WCell.Util.Threading.Message1`1.#ctor(`0,System.Action{`0})">
            <summary>
            Constructs a message with the specific callback and input parameter.
            </summary>
            <param name="callback">the callback to invoke when the message is executed</param>
            <param name="param1">the first input parameter</param>
        </member>
        <member name="M:WCell.Util.Threading.Message1`1.Execute">
            <summary>
            Executes the message, calling any callbacks that are bound, passing the given input parameters.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message1`1.Callback">
            <summary>
            The callback that is called when the message is executed.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message1`1.Parameter1">
            <summary>
            The first input parameter.
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.Message2`2.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.Message2`2.#ctor(System.Action{`0,`1})">
            <summary>
            Constructs a message with the specific callback.
            </summary>
            <param name="callback">the callback to invoke when the message is executed</param>
        </member>
        <member name="M:WCell.Util.Threading.Message2`2.#ctor(`0,`1,System.Action{`0,`1})">
            <summary>
            Constructs a message with the specific callback and input parameters.
            </summary>
            <param name="callback">the callback to invoke when the message is executed</param>
            <param name="param1">the first input parameter</param>
            <param name="param2">the second input parameter</param>
        </member>
        <member name="M:WCell.Util.Threading.Message2`2.#ctor(`0,`1)">
            <summary>
            Constructs a message with the specific callback and input parameters.
            </summary>
            <param name="callback">the callback to invoke when the message is executed</param>
            <param name="param1">the first input parameter</param>
            <param name="param2">the second input parameter</param>
        </member>
        <member name="M:WCell.Util.Threading.Message2`2.Execute">
            <summary>
            Executes the message, calling any callbacks that are bound, passing the given input parameters.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message2`2.Callback">
            <summary>
            The callback that is called when the message is executed.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message2`2.Parameter1">
            <summary>
            The first input parameter.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message2`2.Parameter2">
            <summary>
            The second input parameter.
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.Message3`3.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.Message3`3.#ctor(System.Action{`0,`1,`2})">
            <summary>
            Constructs a message with the specific callback.
            </summary>
            <param name="callback">the callback to invoke when the message is executed</param>
        </member>
        <member name="M:WCell.Util.Threading.Message3`3.#ctor(`0,`1,`2,System.Action{`0,`1,`2})">
            <summary>
            Constructs a message with the specific callback and input parameters.
            </summary>
            <param name="callback">the callback to invoke when the message is executed</param>
            <param name="param1">the first input parameter</param>
            <param name="param2">the second input parameter</param>
            <param name="param3">the third input parameter</param>
        </member>
        <member name="M:WCell.Util.Threading.Message3`3.Execute">
            <summary>
            Executes the message, calling any callbacks that are bound, passing the given input parameters.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message3`3.Callback">
            <summary>
            The callback that is called when the message is executed.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message3`3.Parameter1">
            <summary>
            The first input parameter.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message3`3.Parameter2">
            <summary>
            The second input parameter.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message3`3.Parameter3">
            <summary>
            The third input parameter.
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.Message4`4.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:WCell.Util.Threading.Message4`4.#ctor(System.Action{`0,`1,`2,`3})">
            <summary>
            Constructs a message with the specific callback.
            </summary>
            <param name="callback">the callback to invoke when the message is executed</param>
        </member>
        <member name="M:WCell.Util.Threading.Message4`4.#ctor(System.Action{`0,`1,`2,`3},`0,`1,`2,`3)">
            <summary>
            Constructs a message with the specific callback and input parameters.
            </summary>
            <param name="callback">the callback to invoke when the message is executed</param>
            <param name="param1">the first input parameter</param>
            <param name="param2">the second input parameter</param>
            <param name="param3">the third input parameter</param>
            <param name="param4">the fourth input parameter</param>
        </member>
        <member name="M:WCell.Util.Threading.Message4`4.Execute">
            <summary>
            Executes the message, calling any callbacks that are bound, passing the given input parameters.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message4`4.Callback">
            <summary>
            The callback that is called when the message is executed.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message4`4.Parameter1">
            <summary>
            The first input parameter.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message4`4.Parameter2">
            <summary>
            The second input parameter.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message4`4.Parameter3">
            <summary>
            The third input parameter.
            </summary>
        </member>
        <member name="P:WCell.Util.Threading.Message4`4.Parameter4">
            <summary>
            The fourth input parameter.
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.AggregateExceptionExtensions">
            <summary>Extension methods for AggregateException.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.AggregateExceptionExtensions.Handle(System.AggregateException,System.Func{System.Exception,System.Boolean},System.Boolean)">
            <summary>Invokes a handler on each Exception contained by this AggregateException.</summary>
            <param name="aggregateException">The AggregateException.</param>
            <param name="predicate">
            The predicate to execute for each exception. The predicate accepts as an argument the Exception
            to be processed and returns a Boolean to indicate whether the exception was handled.
            </param>
            <param name="leaveStructureIntact">
            Whether the rethrown AggregateException should maintain the same hierarchy as the original.
            </param>
        </member>
        <member name="T:WCell.Util.Serialization.SerializerCollection">
            <summary>
            TODO: Fully implement required features
            </summary>
        </member>
        <member name="M:WCell.Util.NLog.LogUtil.SetupConsoleLogging">
            <summary>
            Will enable logging to the console
            </summary>
        </member>
        <member name="M:WCell.Util.NLog.LogUtil.SetupStreamLogging(System.IO.TextWriter)">
            <summary>
            Will enable logging to the console and (if not null) the specified file
            </summary>
        </member>
        <member name="T:WCell.Util.DynamicAccess.IGenericPropertyAccessor`2">
            <summary>
            The IPropertyAccessor interface defines a property
            accessor.
            </summary>
        </member>
        <member name="M:WCell.Util.DynamicAccess.IGenericPropertyAccessor`2.Get(`0)">
            <summary>
            Gets the value stored in the property for 
            the specified target.
            </summary>
            <param name="target">Object to retrieve
            the property from.</param>
            <returns>Property value.</returns>
        </member>
        <member name="M:WCell.Util.DynamicAccess.IGenericPropertyAccessor`2.Set(`0,`1)">
            <summary>
            Sets the value for the property of
            the specified target.
            </summary>
            <param name="target">Object to set the
            property on.</param>
            <param name="value">Property value.</param>
        </member>
        <member name="T:WCell.Util.DB.Xml.SimpleFlatFieldDefinition">
            <summary>
            Single column flat field
            </summary>
        </member>
        <member name="P:WCell.Util.DB.Xml.SimpleFlatFieldDefinition.Table">
            <summary>
            Optional. By default the first specified table
            for the containing DataHolder is used.
            </summary>
        </member>
        <member name="P:WCell.Util.DB.Xml.SimpleFlatFieldDefinition.Column">
            <summary>
            The column from which to copy the value to this Field.
            </summary>
        </member>
        <member name="P:WCell.Util.DB.Xml.SimpleFlatFieldDefinition.DefaultStringValue">
            <summary>
            The column from which to copy the value to this Field.
            </summary>
        </member>
        <member name="T:WCell.Util.DB.Xml.ArrayConstraint">
            <summary>
            Defines length and the Column of an Array
            </summary>
        </member>
        <member name="F:WCell.Util.DB.LightDBDefinitionSet.DefaultTables">
            <summary>
            DefaultTables are the tables that contain the core data of each DataHolder.
            It is ensured that a DataHolder is only valid if it exists in all its DefaultTables.
            </summary>
        </member>
        <member name="M:WCell.Util.DB.LightDBDefinitionSet.LoadDataHolderDefinitions(System.IO.DirectoryInfo)">
            <summary>
            Make sure to call <see cref="M:WCell.Util.DB.LightDBDefinitionSet.LoadTableDefinitions(System.String)"/> prior to this.
            </summary>
            <param name="dir"></param>
        </member>
        <member name="T:WCell.Util.Data.DataHolderMgr">
            <summary>
            Static container and utility class for DataHolder-information
            </summary>
        </member>
        <member name="T:WCell.Util.Threading.TaskParallel.DelegateExtensions">
            <summary>Parallel extensions for the Delegate class.</summary>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.DelegateExtensions.ParallelDynamicInvoke(System.Delegate,System.Object[])">
            <summary>Dynamically invokes (late-bound) in parallel the methods represented by the delegate.</summary>
            <param name="multicastDelegate">The delegate to be invoked.</param>
            <param name="args">An array of objects that are the arguments to pass to the delegates.</param>
            <returns>The return value of one of the delegate invocations.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.DelegateExtensions.WithFailFast(System.Action)">
            <summary>
            Provides a delegate that runs the specified action and fails fast if the action throws an exception.
            </summary>
            <param name="action">The action to invoke.</param>
            <returns>The wrapper delegate.</returns>
        </member>
        <member name="M:WCell.Util.Threading.TaskParallel.DelegateExtensions.WithFailFast``1(System.Func{``0})">
            <summary>
            Provides a delegate that runs the specified function and fails fast if the function throws an exception.
            </summary>
            <param name="function">The function to invoke.</param>
            <returns>The wrapper delegate.</returns>
        </member>
        <member name="M:WCell.Util.StringParser.Eval(System.Type,System.Int64@,System.String,System.Object@,System.Boolean)">
            <summary>
            Evaluates the given (simple) expression
            
            TODO: Use Polish Notation to allow more efficiency and complexity
            TODO: Add operator priority
            </summary>
        </member>
        <member name="T:WCell.Util.DynamicAccess.PropertyAccessorException">
            <summary>
            PropertyAccessorException class.
            </summary>
        </member>
        <member name="T:WCell.Util.IValueSetter">
            <summary>
            </summary>
        </member>
        <member name="M:WCell.Util.IValueSetter.Set(System.Object)">
            <summary>
            </summary>
        </member>
        <member name="T:WCell.Util.CustomGetterSetter">
            <summary>
            </summary>
        </member>
        <member name="T:WCell.Util.Graphics.OBB">
            <summary>
            Orientated Bounding Box
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.OBB.Center">
            <summary>
            Vector3 center of this OBB
            </summary>
        </member>
        <member name="F:WCell.Util.Graphics.OBB.Extent">
            <summary>
            Bounds of this OBB. 
            A single Vector 3 representing the distance from the center point to the edge of the box on all three axis as if it were an AABB.
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.OBB.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:WCell.Util.Graphics.OBB.Intersects(WCell.Util.Graphics.Ray)">
            <summary>
            Checks if a ray intersects the bounding box.
            </summary>
            <returns>null if no intersection, else the time of first contact.</returns>
        </member>
        <member name="M:WCell.Util.Graphics.OBB.Intersects(WCell.Util.Graphics.Ray@,System.Nullable{System.Single}@)">
            <summary>
            Checks if a ray intersects the bounding box.
            </summary>
        </member>
        <member name="P:WCell.Util.Graphics.OBB.Bounds">
            <summary>
            The bounds of the Building in World Space
            </summary>
        </member>
        <member name="M:WCell.Util.DB.IDbWrapper.Query(System.String)">
            <summary>
            Queries the Database with the given query and returns the
            corresponding reader to read the results from
            </summary>
        </member>
        <member name="M:WCell.Util.DB.IDbWrapper.Insert(WCell.Util.DB.KeyValueListBase)">
            <summary>
            Insert new DataHolder into Database
            </summary>
        </member>
        <member name="M:WCell.Util.DB.IDbWrapper.Update(WCell.Util.DB.UpdateKeyValueList)">
            <summary>
            Update DataHolder in Database
            </summary>
        </member>
        <member name="T:WCell.Util.StaticCircularList`1">
            <summary>
            A simple array that is indexed in a circular fashion.
            Elements always start at Tail and end at Head.
            
            Tail greater Head:
            | x | x | H |   |   |   | T | x | x |
            
            Head greater Tail:
            |   |   | T | x | x | x | H |   |   |
            </summary>
        </member>
        <member name="M:WCell.Util.StaticCircularList`1.IncreaseAndWrap(System.Int32)">
            <summary>
            Increases the given number by one and wrapping it around, if it's >= Capacity-1
            </summary>
        </member>
        <member name="M:WCell.Util.StaticCircularList`1.Insert(`0)">
            <summary>
            Sets the Head item.
            Also moves Tail forward, if it was already full, thus replacing the Tail item.
            </summary>
        </member>
        <member name="M:WCell.Util.StaticCircularList`1.GetEnumerator">
            <summary>
            Iterates over all items, starting at Tail and stopping at Head
            </summary>
        </member>
        <member name="P:WCell.Util.StaticCircularList`1.Tail">
            <summary>
            The index of the tail
            </summary>
        </member>
        <member name="P:WCell.Util.StaticCircularList`1.Head">
            <summary>
            The index of the head
            </summary>
        </member>
        <member name="P:WCell.Util.StaticCircularList`1.TailItem">
            <summary>
            The Tail item
            </summary>
        </member>
        <member name="P:WCell.Util.StaticCircularList`1.HeadItem">
            <summary>
            The Head item
            </summary>
        </member>
    </members>
</doc>
